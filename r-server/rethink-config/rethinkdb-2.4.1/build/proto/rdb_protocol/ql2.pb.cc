// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: rdb_protocol/ql2.proto

#include "rdb_protocol/ql2.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
extern PROTOBUF_INTERNAL_EXPORT_rdb_5fprotocol_2fql2_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_Backtrace_rdb_5fprotocol_2fql2_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_rdb_5fprotocol_2fql2_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_Datum_rdb_5fprotocol_2fql2_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_rdb_5fprotocol_2fql2_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_Frame_rdb_5fprotocol_2fql2_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_rdb_5fprotocol_2fql2_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_Query_AssocPair_rdb_5fprotocol_2fql2_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_rdb_5fprotocol_2fql2_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_Term_rdb_5fprotocol_2fql2_2eproto;
class VersionDummyDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<VersionDummy> _instance;
} _VersionDummy_default_instance_;
class Query_AssocPairDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<Query_AssocPair> _instance;
} _Query_AssocPair_default_instance_;
class QueryDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<Query> _instance;
} _Query_default_instance_;
class FrameDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<Frame> _instance;
} _Frame_default_instance_;
class BacktraceDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<Backtrace> _instance;
} _Backtrace_default_instance_;
class ResponseDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<Response> _instance;
} _Response_default_instance_;
class Datum_AssocPairDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<Datum_AssocPair> _instance;
} _Datum_AssocPair_default_instance_;
class DatumDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<Datum> _instance;
} _Datum_default_instance_;
class Term_AssocPairDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<Term_AssocPair> _instance;
} _Term_AssocPair_default_instance_;
class TermDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<Term> _instance;
} _Term_default_instance_;
static void InitDefaultsscc_info_Backtrace_rdb_5fprotocol_2fql2_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::_Backtrace_default_instance_;
    new (ptr) ::Backtrace();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::Backtrace::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_Backtrace_rdb_5fprotocol_2fql2_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 1, 0, InitDefaultsscc_info_Backtrace_rdb_5fprotocol_2fql2_2eproto}, {
      &scc_info_Frame_rdb_5fprotocol_2fql2_2eproto.base,}};

static void InitDefaultsscc_info_Datum_rdb_5fprotocol_2fql2_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::_Datum_AssocPair_default_instance_;
    new (ptr) ::Datum_AssocPair();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  {
    void* ptr = &::_Datum_default_instance_;
    new (ptr) ::Datum();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::Datum_AssocPair::InitAsDefaultInstance();
  ::Datum::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_Datum_rdb_5fprotocol_2fql2_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, 0, InitDefaultsscc_info_Datum_rdb_5fprotocol_2fql2_2eproto}, {}};

static void InitDefaultsscc_info_Frame_rdb_5fprotocol_2fql2_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::_Frame_default_instance_;
    new (ptr) ::Frame();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::Frame::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_Frame_rdb_5fprotocol_2fql2_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, 0, InitDefaultsscc_info_Frame_rdb_5fprotocol_2fql2_2eproto}, {}};

static void InitDefaultsscc_info_Query_rdb_5fprotocol_2fql2_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::_Query_default_instance_;
    new (ptr) ::Query();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::Query::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<2> scc_info_Query_rdb_5fprotocol_2fql2_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 2, 0, InitDefaultsscc_info_Query_rdb_5fprotocol_2fql2_2eproto}, {
      &scc_info_Term_rdb_5fprotocol_2fql2_2eproto.base,
      &scc_info_Query_AssocPair_rdb_5fprotocol_2fql2_2eproto.base,}};

static void InitDefaultsscc_info_Query_AssocPair_rdb_5fprotocol_2fql2_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::_Query_AssocPair_default_instance_;
    new (ptr) ::Query_AssocPair();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::Query_AssocPair::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_Query_AssocPair_rdb_5fprotocol_2fql2_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 1, 0, InitDefaultsscc_info_Query_AssocPair_rdb_5fprotocol_2fql2_2eproto}, {
      &scc_info_Term_rdb_5fprotocol_2fql2_2eproto.base,}};

static void InitDefaultsscc_info_Response_rdb_5fprotocol_2fql2_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::_Response_default_instance_;
    new (ptr) ::Response();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::Response::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<2> scc_info_Response_rdb_5fprotocol_2fql2_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 2, 0, InitDefaultsscc_info_Response_rdb_5fprotocol_2fql2_2eproto}, {
      &scc_info_Datum_rdb_5fprotocol_2fql2_2eproto.base,
      &scc_info_Backtrace_rdb_5fprotocol_2fql2_2eproto.base,}};

static void InitDefaultsscc_info_Term_rdb_5fprotocol_2fql2_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::_Term_AssocPair_default_instance_;
    new (ptr) ::Term_AssocPair();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  {
    void* ptr = &::_Term_default_instance_;
    new (ptr) ::Term();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::Term_AssocPair::InitAsDefaultInstance();
  ::Term::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_Term_rdb_5fprotocol_2fql2_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 1, 0, InitDefaultsscc_info_Term_rdb_5fprotocol_2fql2_2eproto}, {
      &scc_info_Datum_rdb_5fprotocol_2fql2_2eproto.base,}};

static void InitDefaultsscc_info_VersionDummy_rdb_5fprotocol_2fql2_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::_VersionDummy_default_instance_;
    new (ptr) ::VersionDummy();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::VersionDummy::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_VersionDummy_rdb_5fprotocol_2fql2_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, 0, InitDefaultsscc_info_VersionDummy_rdb_5fprotocol_2fql2_2eproto}, {}};

static ::PROTOBUF_NAMESPACE_ID::Metadata file_level_metadata_rdb_5fprotocol_2fql2_2eproto[10];
static const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* file_level_enum_descriptors_rdb_5fprotocol_2fql2_2eproto[9];
static constexpr ::PROTOBUF_NAMESPACE_ID::ServiceDescriptor const** file_level_service_descriptors_rdb_5fprotocol_2fql2_2eproto = nullptr;

const ::PROTOBUF_NAMESPACE_ID::uint32 TableStruct_rdb_5fprotocol_2fql2_2eproto::offsets[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  PROTOBUF_FIELD_OFFSET(::VersionDummy, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::VersionDummy, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::Query_AssocPair, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::Query_AssocPair, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::Query_AssocPair, key_),
  PROTOBUF_FIELD_OFFSET(::Query_AssocPair, val_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::Query, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::Query, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::Query, type_),
  PROTOBUF_FIELD_OFFSET(::Query, query_),
  PROTOBUF_FIELD_OFFSET(::Query, token_),
  PROTOBUF_FIELD_OFFSET(::Query, obsolete_noreply_),
  PROTOBUF_FIELD_OFFSET(::Query, accepts_r_json_),
  PROTOBUF_FIELD_OFFSET(::Query, global_optargs_),
  4,
  0,
  1,
  2,
  3,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::Frame, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::Frame, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::Frame, type_),
  PROTOBUF_FIELD_OFFSET(::Frame, pos_),
  PROTOBUF_FIELD_OFFSET(::Frame, opt_),
  2,
  1,
  0,
  PROTOBUF_FIELD_OFFSET(::Backtrace, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::Backtrace, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::Backtrace, frames_),
  ~0u,
  PROTOBUF_FIELD_OFFSET(::Response, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::Response, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::Response, type_),
  PROTOBUF_FIELD_OFFSET(::Response, error_type_),
  PROTOBUF_FIELD_OFFSET(::Response, notes_),
  PROTOBUF_FIELD_OFFSET(::Response, token_),
  PROTOBUF_FIELD_OFFSET(::Response, response_),
  PROTOBUF_FIELD_OFFSET(::Response, backtrace_),
  PROTOBUF_FIELD_OFFSET(::Response, profile_),
  3,
  4,
  ~0u,
  2,
  ~0u,
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::Datum_AssocPair, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::Datum_AssocPair, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::Datum_AssocPair, key_),
  PROTOBUF_FIELD_OFFSET(::Datum_AssocPair, val_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::Datum, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::Datum, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::Datum, type_),
  PROTOBUF_FIELD_OFFSET(::Datum, r_bool_),
  PROTOBUF_FIELD_OFFSET(::Datum, r_num_),
  PROTOBUF_FIELD_OFFSET(::Datum, r_str_),
  PROTOBUF_FIELD_OFFSET(::Datum, r_array_),
  PROTOBUF_FIELD_OFFSET(::Datum, r_object_),
  3,
  2,
  1,
  0,
  ~0u,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::Term_AssocPair, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::Term_AssocPair, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::Term_AssocPair, key_),
  PROTOBUF_FIELD_OFFSET(::Term_AssocPair, val_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::Term, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::Term, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::Term, type_),
  PROTOBUF_FIELD_OFFSET(::Term, datum_),
  PROTOBUF_FIELD_OFFSET(::Term, args_),
  PROTOBUF_FIELD_OFFSET(::Term, optargs_),
  1,
  0,
  ~0u,
  ~0u,
};
static const ::PROTOBUF_NAMESPACE_ID::internal::MigrationSchema schemas[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  { 0, 5, sizeof(::VersionDummy)},
  { 5, 12, sizeof(::Query_AssocPair)},
  { 14, 25, sizeof(::Query)},
  { 31, 39, sizeof(::Frame)},
  { 42, 48, sizeof(::Backtrace)},
  { 49, 61, sizeof(::Response)},
  { 68, 75, sizeof(::Datum_AssocPair)},
  { 77, 88, sizeof(::Datum)},
  { 94, 101, sizeof(::Term_AssocPair)},
  { 103, 112, sizeof(::Term)},
};

static ::PROTOBUF_NAMESPACE_ID::Message const * const file_default_instances[] = {
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_VersionDummy_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_Query_AssocPair_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_Query_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_Frame_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_Backtrace_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_Response_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_Datum_AssocPair_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_Datum_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_Term_AssocPair_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_Term_default_instance_),
};

const char descriptor_table_protodef_rdb_5fprotocol_2fql2_2eproto[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) =
  "\n\026rdb_protocol/ql2.proto\"\213\001\n\014VersionDumm"
  "y\"O\n\007Version\022\014\n\004V0_1\020\266\364\206\373\003\022\014\n\004V0_2\020\341\203\302\221\007"
  "\022\014\n\004V0_3\020\276\320\327\373\005\022\014\n\004V0_4\020\240\332\260\200\004\022\014\n\004V1_0\020\303\373\212"
  "\246\003\"*\n\010Protocol\022\020\n\010PROTOBUF\020\301\370\377\270\002\022\014\n\004JSON"
  "\020\307\341\245\363\007\"\267\002\n\005Query\022\036\n\004type\030\001 \001(\0162\020.Query.Q"
  "ueryType\022\024\n\005query\030\002 \001(\0132\005.Term\022\r\n\005token\030"
  "\003 \001(\003\022\037\n\020OBSOLETE_noreply\030\004 \001(\010:\005false\022\035"
  "\n\016accepts_r_json\030\005 \001(\010:\005false\022(\n\016global_"
  "optargs\030\006 \003(\0132\020.Query.AssocPair\032,\n\tAssoc"
  "Pair\022\013\n\003key\030\001 \001(\t\022\022\n\003val\030\002 \001(\0132\005.Term\"Q\n"
  "\tQueryType\022\t\n\005START\020\001\022\014\n\010CONTINUE\020\002\022\010\n\004S"
  "TOP\020\003\022\020\n\014NOREPLY_WAIT\020\004\022\017\n\013SERVER_INFO\020\005"
  "\"`\n\005Frame\022\036\n\004type\030\001 \001(\0162\020.Frame.FrameTyp"
  "e\022\013\n\003pos\030\002 \001(\003\022\013\n\003opt\030\003 \001(\t\"\035\n\tFrameType"
  "\022\007\n\003POS\020\001\022\007\n\003OPT\020\002\"#\n\tBacktrace\022\026\n\006frame"
  "s\030\001 \003(\0132\006.Frame\"\254\005\n\010Response\022$\n\004type\030\001 \001"
  "(\0162\026.Response.ResponseType\022\'\n\nerror_type"
  "\030\007 \001(\0162\023.Response.ErrorType\022%\n\005notes\030\006 \003"
  "(\0162\026.Response.ResponseNote\022\r\n\005token\030\002 \001("
  "\003\022\030\n\010response\030\003 \003(\0132\006.Datum\022\035\n\tbacktrace"
  "\030\004 \001(\0132\n.Backtrace\022\027\n\007profile\030\005 \001(\0132\006.Da"
  "tum\"\247\001\n\014ResponseType\022\020\n\014SUCCESS_ATOM\020\001\022\024"
  "\n\020SUCCESS_SEQUENCE\020\002\022\023\n\017SUCCESS_PARTIAL\020"
  "\003\022\021\n\rWAIT_COMPLETE\020\004\022\017\n\013SERVER_INFO\020\005\022\020\n"
  "\014CLIENT_ERROR\020\020\022\021\n\rCOMPILE_ERROR\020\021\022\021\n\rRU"
  "NTIME_ERROR\020\022\"\254\001\n\tErrorType\022\016\n\010INTERNAL\020"
  "\300\204=\022\024\n\016RESOURCE_LIMIT\020\200\211z\022\022\n\013QUERY_LOGIC"
  "\020\300\215\267\001\022\024\n\rNON_EXISTENCE\020\340\232\275\001\022\020\n\tOP_FAILED"
  "\020\240\237\372\001\022\027\n\020OP_INDETERMINATE\020\300\254\200\002\022\013\n\004USER\020\300"
  "\226\261\002\022\027\n\020PERMISSION_ERROR\020\200\233\356\002\"p\n\014Response"
  "Note\022\021\n\rSEQUENCE_FEED\020\001\022\r\n\tATOM_FEED\020\002\022\027"
  "\n\023ORDER_BY_LIMIT_FEED\020\003\022\020\n\014UNIONED_FEED\020"
  "\004\022\023\n\017INCLUDES_STATES\020\005\"\243\002\n\005Datum\022\036\n\004type"
  "\030\001 \001(\0162\020.Datum.DatumType\022\016\n\006r_bool\030\002 \001(\010"
  "\022\r\n\005r_num\030\003 \001(\001\022\r\n\005r_str\030\004 \001(\t\022\027\n\007r_arra"
  "y\030\005 \003(\0132\006.Datum\022\"\n\010r_object\030\006 \003(\0132\020.Datu"
  "m.AssocPair\032-\n\tAssocPair\022\013\n\003key\030\001 \001(\t\022\023\n"
  "\003val\030\002 \001(\0132\006.Datum\"`\n\tDatumType\022\n\n\006R_NUL"
  "L\020\001\022\n\n\006R_BOOL\020\002\022\t\n\005R_NUM\020\003\022\t\n\005R_STR\020\004\022\013\n"
  "\007R_ARRAY\020\005\022\014\n\010R_OBJECT\020\006\022\n\n\006R_JSON\020\007\"\300\024\n"
  "\004Term\022\034\n\004type\030\001 \001(\0162\016.Term.TermType\022\025\n\005d"
  "atum\030\002 \001(\0132\006.Datum\022\023\n\004args\030\003 \003(\0132\005.Term\022"
  " \n\007optargs\030\004 \003(\0132\017.Term.AssocPair\032,\n\tAss"
  "ocPair\022\013\n\003key\030\001 \001(\t\022\022\n\003val\030\002 \001(\0132\005.Term\""
  "\235\023\n\010TermType\022\t\n\005DATUM\020\001\022\016\n\nMAKE_ARRAY\020\002\022"
  "\014\n\010MAKE_OBJ\020\003\022\007\n\003VAR\020\n\022\016\n\nJAVASCRIPT\020\013\022\t"
  "\n\004UUID\020\251\001\022\t\n\004HTTP\020\231\001\022\t\n\005ERROR\020\014\022\020\n\014IMPLI"
  "CIT_VAR\020\r\022\006\n\002DB\020\016\022\t\n\005TABLE\020\017\022\007\n\003GET\020\020\022\013\n"
  "\007GET_ALL\020N\022\006\n\002EQ\020\021\022\006\n\002NE\020\022\022\006\n\002LT\020\023\022\006\n\002LE"
  "\020\024\022\006\n\002GT\020\025\022\006\n\002GE\020\026\022\007\n\003NOT\020\027\022\007\n\003ADD\020\030\022\007\n\003"
  "SUB\020\031\022\007\n\003MUL\020\032\022\007\n\003DIV\020\033\022\007\n\003MOD\020\034\022\n\n\005FLOO"
  "R\020\267\001\022\t\n\004CEIL\020\270\001\022\n\n\005ROUND\020\271\001\022\n\n\006APPEND\020\035\022"
  "\013\n\007PREPEND\020P\022\016\n\nDIFFERENCE\020_\022\016\n\nSET_INSE"
  "RT\020X\022\024\n\020SET_INTERSECTION\020Y\022\r\n\tSET_UNION\020"
  "Z\022\022\n\016SET_DIFFERENCE\020[\022\t\n\005SLICE\020\036\022\010\n\004SKIP"
  "\020F\022\t\n\005LIMIT\020G\022\016\n\nOFFSETS_OF\020W\022\014\n\010CONTAIN"
  "S\020]\022\r\n\tGET_FIELD\020\037\022\010\n\004KEYS\020^\022\013\n\006VALUES\020\272"
  "\001\022\013\n\006OBJECT\020\217\001\022\016\n\nHAS_FIELDS\020 \022\017\n\013WITH_F"
  "IELDS\020`\022\t\n\005PLUCK\020!\022\013\n\007WITHOUT\020\"\022\t\n\005MERGE"
  "\020#\022\026\n\022BETWEEN_DEPRECATED\020$\022\014\n\007BETWEEN\020\266\001"
  "\022\n\n\006REDUCE\020%\022\007\n\003MAP\020&\022\t\n\004FOLD\020\273\001\022\n\n\006FILT"
  "ER\020\'\022\016\n\nCONCAT_MAP\020(\022\014\n\010ORDER_BY\020)\022\014\n\010DI"
  "STINCT\020*\022\t\n\005COUNT\020+\022\014\n\010IS_EMPTY\020V\022\t\n\005UNI"
  "ON\020,\022\007\n\003NTH\020-\022\014\n\007BRACKET\020\252\001\022\016\n\nINNER_JOI"
  "N\0200\022\016\n\nOUTER_JOIN\0201\022\013\n\007EQ_JOIN\0202\022\007\n\003ZIP\020"
  "H\022\n\n\005RANGE\020\255\001\022\r\n\tINSERT_AT\020R\022\r\n\tDELETE_A"
  "T\020S\022\r\n\tCHANGE_AT\020T\022\r\n\tSPLICE_AT\020U\022\r\n\tCOE"
  "RCE_TO\0203\022\013\n\007TYPE_OF\0204\022\n\n\006UPDATE\0205\022\n\n\006DEL"
  "ETE\0206\022\013\n\007REPLACE\0207\022\n\n\006INSERT\0208\022\r\n\tDB_CRE"
  "ATE\0209\022\013\n\007DB_DROP\020:\022\013\n\007DB_LIST\020;\022\020\n\014TABLE"
  "_CREATE\020<\022\016\n\nTABLE_DROP\020=\022\016\n\nTABLE_LIST\020"
  ">\022\013\n\006CONFIG\020\256\001\022\013\n\006STATUS\020\257\001\022\t\n\004WAIT\020\261\001\022\020"
  "\n\013RECONFIGURE\020\260\001\022\016\n\tREBALANCE\020\263\001\022\t\n\004SYNC"
  "\020\212\001\022\n\n\005GRANT\020\274\001\022\020\n\014INDEX_CREATE\020K\022\016\n\nIND"
  "EX_DROP\020L\022\016\n\nINDEX_LIST\020M\022\021\n\014INDEX_STATU"
  "S\020\213\001\022\017\n\nINDEX_WAIT\020\214\001\022\021\n\014INDEX_RENAME\020\234\001"
  "\022\023\n\016SET_WRITE_HOOK\020\275\001\022\023\n\016GET_WRITE_HOOK\020"
  "\276\001\022\013\n\007FUNCALL\020@\022\n\n\006BRANCH\020A\022\006\n\002OR\020B\022\007\n\003A"
  "ND\020C\022\014\n\010FOR_EACH\020D\022\010\n\004FUNC\020E\022\007\n\003ASC\020I\022\010\n"
  "\004DESC\020J\022\010\n\004INFO\020O\022\t\n\005MATCH\020a\022\013\n\006UPCASE\020\215"
  "\001\022\r\n\010DOWNCASE\020\216\001\022\n\n\006SAMPLE\020Q\022\013\n\007DEFAULT\020"
  "\\\022\010\n\004JSON\020b\022\013\n\007ISO8601\020c\022\016\n\nTO_ISO8601\020d"
  "\022\016\n\nEPOCH_TIME\020e\022\021\n\rTO_EPOCH_TIME\020f\022\007\n\003N"
  "OW\020g\022\017\n\013IN_TIMEZONE\020h\022\n\n\006DURING\020i\022\010\n\004DAT"
  "E\020j\022\017\n\013TIME_OF_DAY\020~\022\014\n\010TIMEZONE\020\177\022\t\n\004YE"
  "AR\020\200\001\022\n\n\005MONTH\020\201\001\022\010\n\003DAY\020\202\001\022\020\n\013DAY_OF_WE"
  "EK\020\203\001\022\020\n\013DAY_OF_YEAR\020\204\001\022\n\n\005HOURS\020\205\001\022\014\n\007M"
  "INUTES\020\206\001\022\014\n\007SECONDS\020\207\001\022\t\n\004TIME\020\210\001\022\n\n\006MO"
  "NDAY\020k\022\013\n\007TUESDAY\020l\022\r\n\tWEDNESDAY\020m\022\014\n\010TH"
  "URSDAY\020n\022\n\n\006FRIDAY\020o\022\014\n\010SATURDAY\020p\022\n\n\006SU"
  "NDAY\020q\022\013\n\007JANUARY\020r\022\014\n\010FEBRUARY\020s\022\t\n\005MAR"
  "CH\020t\022\t\n\005APRIL\020u\022\007\n\003MAY\020v\022\010\n\004JUNE\020w\022\010\n\004JU"
  "LY\020x\022\n\n\006AUGUST\020y\022\r\n\tSEPTEMBER\020z\022\013\n\007OCTOB"
  "ER\020{\022\014\n\010NOVEMBER\020|\022\014\n\010DECEMBER\020}\022\014\n\007LITE"
  "RAL\020\211\001\022\n\n\005GROUP\020\220\001\022\010\n\003SUM\020\221\001\022\010\n\003AVG\020\222\001\022\010"
  "\n\003MIN\020\223\001\022\010\n\003MAX\020\224\001\022\n\n\005SPLIT\020\225\001\022\014\n\007UNGROU"
  "P\020\226\001\022\013\n\006RANDOM\020\227\001\022\014\n\007CHANGES\020\230\001\022\t\n\004ARGS\020"
  "\232\001\022\013\n\006BINARY\020\233\001\022\014\n\007GEOJSON\020\235\001\022\017\n\nTO_GEOJ"
  "SON\020\236\001\022\n\n\005POINT\020\237\001\022\t\n\004LINE\020\240\001\022\014\n\007POLYGON"
  "\020\241\001\022\r\n\010DISTANCE\020\242\001\022\017\n\nINTERSECTS\020\243\001\022\r\n\010I"
  "NCLUDES\020\244\001\022\013\n\006CIRCLE\020\245\001\022\025\n\020GET_INTERSECT"
  "ING\020\246\001\022\t\n\004FILL\020\247\001\022\020\n\013GET_NEAREST\020\250\001\022\020\n\013P"
  "OLYGON_SUB\020\253\001\022\023\n\016TO_JSON_STRING\020\254\001\022\013\n\006MI"
  "NVAL\020\264\001\022\013\n\006MAXVAL\020\265\001\022\014\n\007BIT_AND\020\277\001\022\013\n\006BI"
  "T_OR\020\300\001\022\014\n\007BIT_XOR\020\301\001\022\014\n\007BIT_NOT\020\302\001\022\014\n\007B"
  "IT_SAL\020\303\001\022\014\n\007BIT_SAR\020\304\001"
  ;
static const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable*const descriptor_table_rdb_5fprotocol_2fql2_2eproto_deps[1] = {
};
static ::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase*const descriptor_table_rdb_5fprotocol_2fql2_2eproto_sccs[8] = {
  &scc_info_Backtrace_rdb_5fprotocol_2fql2_2eproto.base,
  &scc_info_Datum_rdb_5fprotocol_2fql2_2eproto.base,
  &scc_info_Frame_rdb_5fprotocol_2fql2_2eproto.base,
  &scc_info_Query_rdb_5fprotocol_2fql2_2eproto.base,
  &scc_info_Query_AssocPair_rdb_5fprotocol_2fql2_2eproto.base,
  &scc_info_Response_rdb_5fprotocol_2fql2_2eproto.base,
  &scc_info_Term_rdb_5fprotocol_2fql2_2eproto.base,
  &scc_info_VersionDummy_rdb_5fprotocol_2fql2_2eproto.base,
};
static ::PROTOBUF_NAMESPACE_ID::internal::once_flag descriptor_table_rdb_5fprotocol_2fql2_2eproto_once;
static bool descriptor_table_rdb_5fprotocol_2fql2_2eproto_initialized = false;
const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_rdb_5fprotocol_2fql2_2eproto = {
  &descriptor_table_rdb_5fprotocol_2fql2_2eproto_initialized, descriptor_table_protodef_rdb_5fprotocol_2fql2_2eproto, "rdb_protocol/ql2.proto", 4223,
  &descriptor_table_rdb_5fprotocol_2fql2_2eproto_once, descriptor_table_rdb_5fprotocol_2fql2_2eproto_sccs, descriptor_table_rdb_5fprotocol_2fql2_2eproto_deps, 8, 0,
  schemas, file_default_instances, TableStruct_rdb_5fprotocol_2fql2_2eproto::offsets,
  file_level_metadata_rdb_5fprotocol_2fql2_2eproto, 10, file_level_enum_descriptors_rdb_5fprotocol_2fql2_2eproto, file_level_service_descriptors_rdb_5fprotocol_2fql2_2eproto,
};

// Force running AddDescriptors() at dynamic initialization time.
static bool dynamic_init_dummy_rdb_5fprotocol_2fql2_2eproto = (  ::PROTOBUF_NAMESPACE_ID::internal::AddDescriptors(&descriptor_table_rdb_5fprotocol_2fql2_2eproto), true);
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* VersionDummy_Version_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_rdb_5fprotocol_2fql2_2eproto);
  return file_level_enum_descriptors_rdb_5fprotocol_2fql2_2eproto[0];
}
bool VersionDummy_Version_IsValid(int value) {
  switch (value) {
    case 885177795:
    case 1063369270:
    case 1074539808:
    case 1601562686:
    case 1915781601:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
constexpr VersionDummy_Version VersionDummy::V0_1;
constexpr VersionDummy_Version VersionDummy::V0_2;
constexpr VersionDummy_Version VersionDummy::V0_3;
constexpr VersionDummy_Version VersionDummy::V0_4;
constexpr VersionDummy_Version VersionDummy::V1_0;
constexpr VersionDummy_Version VersionDummy::Version_MIN;
constexpr VersionDummy_Version VersionDummy::Version_MAX;
constexpr int VersionDummy::Version_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* VersionDummy_Protocol_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_rdb_5fprotocol_2fql2_2eproto);
  return file_level_enum_descriptors_rdb_5fprotocol_2fql2_2eproto[1];
}
bool VersionDummy_Protocol_IsValid(int value) {
  switch (value) {
    case 656407617:
    case 2120839367:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
constexpr VersionDummy_Protocol VersionDummy::PROTOBUF;
constexpr VersionDummy_Protocol VersionDummy::JSON;
constexpr VersionDummy_Protocol VersionDummy::Protocol_MIN;
constexpr VersionDummy_Protocol VersionDummy::Protocol_MAX;
constexpr int VersionDummy::Protocol_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Query_QueryType_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_rdb_5fprotocol_2fql2_2eproto);
  return file_level_enum_descriptors_rdb_5fprotocol_2fql2_2eproto[2];
}
bool Query_QueryType_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
constexpr Query_QueryType Query::START;
constexpr Query_QueryType Query::CONTINUE;
constexpr Query_QueryType Query::STOP;
constexpr Query_QueryType Query::NOREPLY_WAIT;
constexpr Query_QueryType Query::SERVER_INFO;
constexpr Query_QueryType Query::QueryType_MIN;
constexpr Query_QueryType Query::QueryType_MAX;
constexpr int Query::QueryType_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Frame_FrameType_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_rdb_5fprotocol_2fql2_2eproto);
  return file_level_enum_descriptors_rdb_5fprotocol_2fql2_2eproto[3];
}
bool Frame_FrameType_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
constexpr Frame_FrameType Frame::POS;
constexpr Frame_FrameType Frame::OPT;
constexpr Frame_FrameType Frame::FrameType_MIN;
constexpr Frame_FrameType Frame::FrameType_MAX;
constexpr int Frame::FrameType_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Response_ResponseType_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_rdb_5fprotocol_2fql2_2eproto);
  return file_level_enum_descriptors_rdb_5fprotocol_2fql2_2eproto[4];
}
bool Response_ResponseType_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 16:
    case 17:
    case 18:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
constexpr Response_ResponseType Response::SUCCESS_ATOM;
constexpr Response_ResponseType Response::SUCCESS_SEQUENCE;
constexpr Response_ResponseType Response::SUCCESS_PARTIAL;
constexpr Response_ResponseType Response::WAIT_COMPLETE;
constexpr Response_ResponseType Response::SERVER_INFO;
constexpr Response_ResponseType Response::CLIENT_ERROR;
constexpr Response_ResponseType Response::COMPILE_ERROR;
constexpr Response_ResponseType Response::RUNTIME_ERROR;
constexpr Response_ResponseType Response::ResponseType_MIN;
constexpr Response_ResponseType Response::ResponseType_MAX;
constexpr int Response::ResponseType_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Response_ErrorType_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_rdb_5fprotocol_2fql2_2eproto);
  return file_level_enum_descriptors_rdb_5fprotocol_2fql2_2eproto[5];
}
bool Response_ErrorType_IsValid(int value) {
  switch (value) {
    case 1000000:
    case 2000000:
    case 3000000:
    case 3100000:
    case 4100000:
    case 4200000:
    case 5000000:
    case 6000000:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
constexpr Response_ErrorType Response::INTERNAL;
constexpr Response_ErrorType Response::RESOURCE_LIMIT;
constexpr Response_ErrorType Response::QUERY_LOGIC;
constexpr Response_ErrorType Response::NON_EXISTENCE;
constexpr Response_ErrorType Response::OP_FAILED;
constexpr Response_ErrorType Response::OP_INDETERMINATE;
constexpr Response_ErrorType Response::USER;
constexpr Response_ErrorType Response::PERMISSION_ERROR;
constexpr Response_ErrorType Response::ErrorType_MIN;
constexpr Response_ErrorType Response::ErrorType_MAX;
constexpr int Response::ErrorType_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Response_ResponseNote_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_rdb_5fprotocol_2fql2_2eproto);
  return file_level_enum_descriptors_rdb_5fprotocol_2fql2_2eproto[6];
}
bool Response_ResponseNote_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
constexpr Response_ResponseNote Response::SEQUENCE_FEED;
constexpr Response_ResponseNote Response::ATOM_FEED;
constexpr Response_ResponseNote Response::ORDER_BY_LIMIT_FEED;
constexpr Response_ResponseNote Response::UNIONED_FEED;
constexpr Response_ResponseNote Response::INCLUDES_STATES;
constexpr Response_ResponseNote Response::ResponseNote_MIN;
constexpr Response_ResponseNote Response::ResponseNote_MAX;
constexpr int Response::ResponseNote_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Datum_DatumType_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_rdb_5fprotocol_2fql2_2eproto);
  return file_level_enum_descriptors_rdb_5fprotocol_2fql2_2eproto[7];
}
bool Datum_DatumType_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
constexpr Datum_DatumType Datum::R_NULL;
constexpr Datum_DatumType Datum::R_BOOL;
constexpr Datum_DatumType Datum::R_NUM;
constexpr Datum_DatumType Datum::R_STR;
constexpr Datum_DatumType Datum::R_ARRAY;
constexpr Datum_DatumType Datum::R_OBJECT;
constexpr Datum_DatumType Datum::R_JSON;
constexpr Datum_DatumType Datum::DatumType_MIN;
constexpr Datum_DatumType Datum::DatumType_MAX;
constexpr int Datum::DatumType_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Term_TermType_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_rdb_5fprotocol_2fql2_2eproto);
  return file_level_enum_descriptors_rdb_5fprotocol_2fql2_2eproto[8];
}
bool Term_TermType_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
    case 3:
    case 10:
    case 11:
    case 12:
    case 13:
    case 14:
    case 15:
    case 16:
    case 17:
    case 18:
    case 19:
    case 20:
    case 21:
    case 22:
    case 23:
    case 24:
    case 25:
    case 26:
    case 27:
    case 28:
    case 29:
    case 30:
    case 31:
    case 32:
    case 33:
    case 34:
    case 35:
    case 36:
    case 37:
    case 38:
    case 39:
    case 40:
    case 41:
    case 42:
    case 43:
    case 44:
    case 45:
    case 48:
    case 49:
    case 50:
    case 51:
    case 52:
    case 53:
    case 54:
    case 55:
    case 56:
    case 57:
    case 58:
    case 59:
    case 60:
    case 61:
    case 62:
    case 64:
    case 65:
    case 66:
    case 67:
    case 68:
    case 69:
    case 70:
    case 71:
    case 72:
    case 73:
    case 74:
    case 75:
    case 76:
    case 77:
    case 78:
    case 79:
    case 80:
    case 81:
    case 82:
    case 83:
    case 84:
    case 85:
    case 86:
    case 87:
    case 88:
    case 89:
    case 90:
    case 91:
    case 92:
    case 93:
    case 94:
    case 95:
    case 96:
    case 97:
    case 98:
    case 99:
    case 100:
    case 101:
    case 102:
    case 103:
    case 104:
    case 105:
    case 106:
    case 107:
    case 108:
    case 109:
    case 110:
    case 111:
    case 112:
    case 113:
    case 114:
    case 115:
    case 116:
    case 117:
    case 118:
    case 119:
    case 120:
    case 121:
    case 122:
    case 123:
    case 124:
    case 125:
    case 126:
    case 127:
    case 128:
    case 129:
    case 130:
    case 131:
    case 132:
    case 133:
    case 134:
    case 135:
    case 136:
    case 137:
    case 138:
    case 139:
    case 140:
    case 141:
    case 142:
    case 143:
    case 144:
    case 145:
    case 146:
    case 147:
    case 148:
    case 149:
    case 150:
    case 151:
    case 152:
    case 153:
    case 154:
    case 155:
    case 156:
    case 157:
    case 158:
    case 159:
    case 160:
    case 161:
    case 162:
    case 163:
    case 164:
    case 165:
    case 166:
    case 167:
    case 168:
    case 169:
    case 170:
    case 171:
    case 172:
    case 173:
    case 174:
    case 175:
    case 176:
    case 177:
    case 179:
    case 180:
    case 181:
    case 182:
    case 183:
    case 184:
    case 185:
    case 186:
    case 187:
    case 188:
    case 189:
    case 190:
    case 191:
    case 192:
    case 193:
    case 194:
    case 195:
    case 196:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
constexpr Term_TermType Term::DATUM;
constexpr Term_TermType Term::MAKE_ARRAY;
constexpr Term_TermType Term::MAKE_OBJ;
constexpr Term_TermType Term::VAR;
constexpr Term_TermType Term::JAVASCRIPT;
constexpr Term_TermType Term::UUID;
constexpr Term_TermType Term::HTTP;
constexpr Term_TermType Term::ERROR;
constexpr Term_TermType Term::IMPLICIT_VAR;
constexpr Term_TermType Term::DB;
constexpr Term_TermType Term::TABLE;
constexpr Term_TermType Term::GET;
constexpr Term_TermType Term::GET_ALL;
constexpr Term_TermType Term::EQ;
constexpr Term_TermType Term::NE;
constexpr Term_TermType Term::LT;
constexpr Term_TermType Term::LE;
constexpr Term_TermType Term::GT;
constexpr Term_TermType Term::GE;
constexpr Term_TermType Term::NOT;
constexpr Term_TermType Term::ADD;
constexpr Term_TermType Term::SUB;
constexpr Term_TermType Term::MUL;
constexpr Term_TermType Term::DIV;
constexpr Term_TermType Term::MOD;
constexpr Term_TermType Term::FLOOR;
constexpr Term_TermType Term::CEIL;
constexpr Term_TermType Term::ROUND;
constexpr Term_TermType Term::APPEND;
constexpr Term_TermType Term::PREPEND;
constexpr Term_TermType Term::DIFFERENCE;
constexpr Term_TermType Term::SET_INSERT;
constexpr Term_TermType Term::SET_INTERSECTION;
constexpr Term_TermType Term::SET_UNION;
constexpr Term_TermType Term::SET_DIFFERENCE;
constexpr Term_TermType Term::SLICE;
constexpr Term_TermType Term::SKIP;
constexpr Term_TermType Term::LIMIT;
constexpr Term_TermType Term::OFFSETS_OF;
constexpr Term_TermType Term::CONTAINS;
constexpr Term_TermType Term::GET_FIELD;
constexpr Term_TermType Term::KEYS;
constexpr Term_TermType Term::VALUES;
constexpr Term_TermType Term::OBJECT;
constexpr Term_TermType Term::HAS_FIELDS;
constexpr Term_TermType Term::WITH_FIELDS;
constexpr Term_TermType Term::PLUCK;
constexpr Term_TermType Term::WITHOUT;
constexpr Term_TermType Term::MERGE;
constexpr Term_TermType Term::BETWEEN_DEPRECATED;
constexpr Term_TermType Term::BETWEEN;
constexpr Term_TermType Term::REDUCE;
constexpr Term_TermType Term::MAP;
constexpr Term_TermType Term::FOLD;
constexpr Term_TermType Term::FILTER;
constexpr Term_TermType Term::CONCAT_MAP;
constexpr Term_TermType Term::ORDER_BY;
constexpr Term_TermType Term::DISTINCT;
constexpr Term_TermType Term::COUNT;
constexpr Term_TermType Term::IS_EMPTY;
constexpr Term_TermType Term::UNION;
constexpr Term_TermType Term::NTH;
constexpr Term_TermType Term::BRACKET;
constexpr Term_TermType Term::INNER_JOIN;
constexpr Term_TermType Term::OUTER_JOIN;
constexpr Term_TermType Term::EQ_JOIN;
constexpr Term_TermType Term::ZIP;
constexpr Term_TermType Term::RANGE;
constexpr Term_TermType Term::INSERT_AT;
constexpr Term_TermType Term::DELETE_AT;
constexpr Term_TermType Term::CHANGE_AT;
constexpr Term_TermType Term::SPLICE_AT;
constexpr Term_TermType Term::COERCE_TO;
constexpr Term_TermType Term::TYPE_OF;
constexpr Term_TermType Term::UPDATE;
constexpr Term_TermType Term::DELETE;
constexpr Term_TermType Term::REPLACE;
constexpr Term_TermType Term::INSERT;
constexpr Term_TermType Term::DB_CREATE;
constexpr Term_TermType Term::DB_DROP;
constexpr Term_TermType Term::DB_LIST;
constexpr Term_TermType Term::TABLE_CREATE;
constexpr Term_TermType Term::TABLE_DROP;
constexpr Term_TermType Term::TABLE_LIST;
constexpr Term_TermType Term::CONFIG;
constexpr Term_TermType Term::STATUS;
constexpr Term_TermType Term::WAIT;
constexpr Term_TermType Term::RECONFIGURE;
constexpr Term_TermType Term::REBALANCE;
constexpr Term_TermType Term::SYNC;
constexpr Term_TermType Term::GRANT;
constexpr Term_TermType Term::INDEX_CREATE;
constexpr Term_TermType Term::INDEX_DROP;
constexpr Term_TermType Term::INDEX_LIST;
constexpr Term_TermType Term::INDEX_STATUS;
constexpr Term_TermType Term::INDEX_WAIT;
constexpr Term_TermType Term::INDEX_RENAME;
constexpr Term_TermType Term::SET_WRITE_HOOK;
constexpr Term_TermType Term::GET_WRITE_HOOK;
constexpr Term_TermType Term::FUNCALL;
constexpr Term_TermType Term::BRANCH;
constexpr Term_TermType Term::OR;
constexpr Term_TermType Term::AND;
constexpr Term_TermType Term::FOR_EACH;
constexpr Term_TermType Term::FUNC;
constexpr Term_TermType Term::ASC;
constexpr Term_TermType Term::DESC;
constexpr Term_TermType Term::INFO;
constexpr Term_TermType Term::MATCH;
constexpr Term_TermType Term::UPCASE;
constexpr Term_TermType Term::DOWNCASE;
constexpr Term_TermType Term::SAMPLE;
constexpr Term_TermType Term::DEFAULT;
constexpr Term_TermType Term::JSON;
constexpr Term_TermType Term::ISO8601;
constexpr Term_TermType Term::TO_ISO8601;
constexpr Term_TermType Term::EPOCH_TIME;
constexpr Term_TermType Term::TO_EPOCH_TIME;
constexpr Term_TermType Term::NOW;
constexpr Term_TermType Term::IN_TIMEZONE;
constexpr Term_TermType Term::DURING;
constexpr Term_TermType Term::DATE;
constexpr Term_TermType Term::TIME_OF_DAY;
constexpr Term_TermType Term::TIMEZONE;
constexpr Term_TermType Term::YEAR;
constexpr Term_TermType Term::MONTH;
constexpr Term_TermType Term::DAY;
constexpr Term_TermType Term::DAY_OF_WEEK;
constexpr Term_TermType Term::DAY_OF_YEAR;
constexpr Term_TermType Term::HOURS;
constexpr Term_TermType Term::MINUTES;
constexpr Term_TermType Term::SECONDS;
constexpr Term_TermType Term::TIME;
constexpr Term_TermType Term::MONDAY;
constexpr Term_TermType Term::TUESDAY;
constexpr Term_TermType Term::WEDNESDAY;
constexpr Term_TermType Term::THURSDAY;
constexpr Term_TermType Term::FRIDAY;
constexpr Term_TermType Term::SATURDAY;
constexpr Term_TermType Term::SUNDAY;
constexpr Term_TermType Term::JANUARY;
constexpr Term_TermType Term::FEBRUARY;
constexpr Term_TermType Term::MARCH;
constexpr Term_TermType Term::APRIL;
constexpr Term_TermType Term::MAY;
constexpr Term_TermType Term::JUNE;
constexpr Term_TermType Term::JULY;
constexpr Term_TermType Term::AUGUST;
constexpr Term_TermType Term::SEPTEMBER;
constexpr Term_TermType Term::OCTOBER;
constexpr Term_TermType Term::NOVEMBER;
constexpr Term_TermType Term::DECEMBER;
constexpr Term_TermType Term::LITERAL;
constexpr Term_TermType Term::GROUP;
constexpr Term_TermType Term::SUM;
constexpr Term_TermType Term::AVG;
constexpr Term_TermType Term::MIN;
constexpr Term_TermType Term::MAX;
constexpr Term_TermType Term::SPLIT;
constexpr Term_TermType Term::UNGROUP;
constexpr Term_TermType Term::RANDOM;
constexpr Term_TermType Term::CHANGES;
constexpr Term_TermType Term::ARGS;
constexpr Term_TermType Term::BINARY;
constexpr Term_TermType Term::GEOJSON;
constexpr Term_TermType Term::TO_GEOJSON;
constexpr Term_TermType Term::POINT;
constexpr Term_TermType Term::LINE;
constexpr Term_TermType Term::POLYGON;
constexpr Term_TermType Term::DISTANCE;
constexpr Term_TermType Term::INTERSECTS;
constexpr Term_TermType Term::INCLUDES;
constexpr Term_TermType Term::CIRCLE;
constexpr Term_TermType Term::GET_INTERSECTING;
constexpr Term_TermType Term::FILL;
constexpr Term_TermType Term::GET_NEAREST;
constexpr Term_TermType Term::POLYGON_SUB;
constexpr Term_TermType Term::TO_JSON_STRING;
constexpr Term_TermType Term::MINVAL;
constexpr Term_TermType Term::MAXVAL;
constexpr Term_TermType Term::BIT_AND;
constexpr Term_TermType Term::BIT_OR;
constexpr Term_TermType Term::BIT_XOR;
constexpr Term_TermType Term::BIT_NOT;
constexpr Term_TermType Term::BIT_SAL;
constexpr Term_TermType Term::BIT_SAR;
constexpr Term_TermType Term::TermType_MIN;
constexpr Term_TermType Term::TermType_MAX;
constexpr int Term::TermType_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)

// ===================================================================

void VersionDummy::InitAsDefaultInstance() {
}
class VersionDummy::_Internal {
 public:
  using HasBits = decltype(std::declval<VersionDummy>()._has_bits_);
};

VersionDummy::VersionDummy()
  : ::PROTOBUF_NAMESPACE_ID::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:VersionDummy)
}
VersionDummy::VersionDummy(const VersionDummy& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:VersionDummy)
}

void VersionDummy::SharedCtor() {
}

VersionDummy::~VersionDummy() {
  // @@protoc_insertion_point(destructor:VersionDummy)
  SharedDtor();
}

void VersionDummy::SharedDtor() {
}

void VersionDummy::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const VersionDummy& VersionDummy::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_VersionDummy_rdb_5fprotocol_2fql2_2eproto.base);
  return *internal_default_instance();
}


void VersionDummy::Clear() {
// @@protoc_insertion_point(message_clear_start:VersionDummy)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

const char* VersionDummy::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
  }  // while
success:
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* VersionDummy::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:VersionDummy)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:VersionDummy)
  return target;
}

size_t VersionDummy::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:VersionDummy)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void VersionDummy::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:VersionDummy)
  GOOGLE_DCHECK_NE(&from, this);
  const VersionDummy* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<VersionDummy>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:VersionDummy)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:VersionDummy)
    MergeFrom(*source);
  }
}

void VersionDummy::MergeFrom(const VersionDummy& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:VersionDummy)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

}

void VersionDummy::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:VersionDummy)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void VersionDummy::CopyFrom(const VersionDummy& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:VersionDummy)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool VersionDummy::IsInitialized() const {
  return true;
}

void VersionDummy::InternalSwap(VersionDummy* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
}

::PROTOBUF_NAMESPACE_ID::Metadata VersionDummy::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void Query_AssocPair::InitAsDefaultInstance() {
  ::_Query_AssocPair_default_instance_._instance.get_mutable()->val_ = const_cast< ::Term*>(
      ::Term::internal_default_instance());
}
class Query_AssocPair::_Internal {
 public:
  using HasBits = decltype(std::declval<Query_AssocPair>()._has_bits_);
  static void set_has_key(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::Term& val(const Query_AssocPair* msg);
  static void set_has_val(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

const ::Term&
Query_AssocPair::_Internal::val(const Query_AssocPair* msg) {
  return *msg->val_;
}
Query_AssocPair::Query_AssocPair()
  : ::PROTOBUF_NAMESPACE_ID::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:Query.AssocPair)
}
Query_AssocPair::Query_AssocPair(const Query_AssocPair& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  key_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_key()) {
    key_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.key_);
  }
  if (from._internal_has_val()) {
    val_ = new ::Term(*from.val_);
  } else {
    val_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:Query.AssocPair)
}

void Query_AssocPair::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_Query_AssocPair_rdb_5fprotocol_2fql2_2eproto.base);
  key_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  val_ = nullptr;
}

Query_AssocPair::~Query_AssocPair() {
  // @@protoc_insertion_point(destructor:Query.AssocPair)
  SharedDtor();
}

void Query_AssocPair::SharedDtor() {
  key_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (this != internal_default_instance()) delete val_;
}

void Query_AssocPair::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const Query_AssocPair& Query_AssocPair::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_Query_AssocPair_rdb_5fprotocol_2fql2_2eproto.base);
  return *internal_default_instance();
}


void Query_AssocPair::Clear() {
// @@protoc_insertion_point(message_clear_start:Query.AssocPair)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      key_.ClearNonDefaultToEmptyNoArena();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(val_ != nullptr);
      val_->Clear();
    }
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

const char* Query_AssocPair::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional string key = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          auto str = _internal_mutable_key();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "Query.AssocPair.key");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .Term val = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_val(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* Query_AssocPair::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:Query.AssocPair)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string key = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_key().data(), static_cast<int>(this->_internal_key().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "Query.AssocPair.key");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_key(), target);
  }

  // optional .Term val = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        2, _Internal::val(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Query.AssocPair)
  return target;
}

size_t Query_AssocPair::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Query.AssocPair)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional string key = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_key());
    }

    // optional .Term val = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *val_);
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Query_AssocPair::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:Query.AssocPair)
  GOOGLE_DCHECK_NE(&from, this);
  const Query_AssocPair* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<Query_AssocPair>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:Query.AssocPair)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:Query.AssocPair)
    MergeFrom(*source);
  }
}

void Query_AssocPair::MergeFrom(const Query_AssocPair& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:Query.AssocPair)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _has_bits_[0] |= 0x00000001u;
      key_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.key_);
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_mutable_val()->::Term::MergeFrom(from._internal_val());
    }
  }
}

void Query_AssocPair::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:Query.AssocPair)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Query_AssocPair::CopyFrom(const Query_AssocPair& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Query.AssocPair)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Query_AssocPair::IsInitialized() const {
  return true;
}

void Query_AssocPair::InternalSwap(Query_AssocPair* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  key_.Swap(&other->key_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  swap(val_, other->val_);
}

::PROTOBUF_NAMESPACE_ID::Metadata Query_AssocPair::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void Query::InitAsDefaultInstance() {
  ::_Query_default_instance_._instance.get_mutable()->query_ = const_cast< ::Term*>(
      ::Term::internal_default_instance());
}
class Query::_Internal {
 public:
  using HasBits = decltype(std::declval<Query>()._has_bits_);
  static void set_has_type(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static const ::Term& query(const Query* msg);
  static void set_has_query(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_token(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_obsolete_noreply(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_accepts_r_json(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

const ::Term&
Query::_Internal::query(const Query* msg) {
  return *msg->query_;
}
Query::Query()
  : ::PROTOBUF_NAMESPACE_ID::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:Query)
}
Query::Query(const Query& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_),
      global_optargs_(from.global_optargs_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  if (from._internal_has_query()) {
    query_ = new ::Term(*from.query_);
  } else {
    query_ = nullptr;
  }
  ::memcpy(&token_, &from.token_,
    static_cast<size_t>(reinterpret_cast<char*>(&type_) -
    reinterpret_cast<char*>(&token_)) + sizeof(type_));
  // @@protoc_insertion_point(copy_constructor:Query)
}

void Query::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_Query_rdb_5fprotocol_2fql2_2eproto.base);
  ::memset(&query_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&accepts_r_json_) -
      reinterpret_cast<char*>(&query_)) + sizeof(accepts_r_json_));
  type_ = 1;
}

Query::~Query() {
  // @@protoc_insertion_point(destructor:Query)
  SharedDtor();
}

void Query::SharedDtor() {
  if (this != internal_default_instance()) delete query_;
}

void Query::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const Query& Query::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_Query_rdb_5fprotocol_2fql2_2eproto.base);
  return *internal_default_instance();
}


void Query::Clear() {
// @@protoc_insertion_point(message_clear_start:Query)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  global_optargs_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(query_ != nullptr);
    query_->Clear();
  }
  if (cached_has_bits & 0x0000001eu) {
    ::memset(&token_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&accepts_r_json_) -
        reinterpret_cast<char*>(&token_)) + sizeof(accepts_r_json_));
    type_ = 1;
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

const char* Query::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional .Query.QueryType type = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::Query_QueryType_IsValid(val))) {
            _internal_set_type(static_cast<::Query_QueryType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else goto handle_unusual;
        continue;
      // optional .Term query = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_query(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int64 token = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          _Internal::set_has_token(&has_bits);
          token_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bool OBSOLETE_noreply = 4 [default = false];
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 32)) {
          _Internal::set_has_obsolete_noreply(&has_bits);
          obsolete_noreply_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bool accepts_r_json = 5 [default = false];
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 40)) {
          _Internal::set_has_accepts_r_json(&has_bits);
          accepts_r_json_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // repeated .Query.AssocPair global_optargs = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 50)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_global_optargs(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<50>(ptr));
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* Query::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:Query)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .Query.QueryType type = 1;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      1, this->_internal_type(), target);
  }

  // optional .Term query = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        2, _Internal::query(this), target, stream);
  }

  // optional int64 token = 3;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64ToArray(3, this->_internal_token(), target);
  }

  // optional bool OBSOLETE_noreply = 4 [default = false];
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(4, this->_internal_obsolete_noreply(), target);
  }

  // optional bool accepts_r_json = 5 [default = false];
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(5, this->_internal_accepts_r_json(), target);
  }

  // repeated .Query.AssocPair global_optargs = 6;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_global_optargs_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(6, this->_internal_global_optargs(i), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Query)
  return target;
}

size_t Query::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Query)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .Query.AssocPair global_optargs = 6;
  total_size += 1UL * this->_internal_global_optargs_size();
  for (const auto& msg : this->global_optargs_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional .Term query = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *query_);
    }

    // optional int64 token = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64Size(
          this->_internal_token());
    }

    // optional bool OBSOLETE_noreply = 4 [default = false];
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 1;
    }

    // optional bool accepts_r_json = 5 [default = false];
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + 1;
    }

    // optional .Query.QueryType type = 1;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_type());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Query::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:Query)
  GOOGLE_DCHECK_NE(&from, this);
  const Query* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<Query>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:Query)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:Query)
    MergeFrom(*source);
  }
}

void Query::MergeFrom(const Query& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:Query)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  global_optargs_.MergeFrom(from.global_optargs_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_mutable_query()->::Term::MergeFrom(from._internal_query());
    }
    if (cached_has_bits & 0x00000002u) {
      token_ = from.token_;
    }
    if (cached_has_bits & 0x00000004u) {
      obsolete_noreply_ = from.obsolete_noreply_;
    }
    if (cached_has_bits & 0x00000008u) {
      accepts_r_json_ = from.accepts_r_json_;
    }
    if (cached_has_bits & 0x00000010u) {
      type_ = from.type_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void Query::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:Query)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Query::CopyFrom(const Query& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Query)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Query::IsInitialized() const {
  return true;
}

void Query::InternalSwap(Query* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  global_optargs_.InternalSwap(&other->global_optargs_);
  swap(query_, other->query_);
  swap(token_, other->token_);
  swap(obsolete_noreply_, other->obsolete_noreply_);
  swap(accepts_r_json_, other->accepts_r_json_);
  swap(type_, other->type_);
}

::PROTOBUF_NAMESPACE_ID::Metadata Query::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void Frame::InitAsDefaultInstance() {
}
class Frame::_Internal {
 public:
  using HasBits = decltype(std::declval<Frame>()._has_bits_);
  static void set_has_type(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_pos(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_opt(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

Frame::Frame()
  : ::PROTOBUF_NAMESPACE_ID::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:Frame)
}
Frame::Frame(const Frame& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  opt_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_opt()) {
    opt_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.opt_);
  }
  ::memcpy(&pos_, &from.pos_,
    static_cast<size_t>(reinterpret_cast<char*>(&type_) -
    reinterpret_cast<char*>(&pos_)) + sizeof(type_));
  // @@protoc_insertion_point(copy_constructor:Frame)
}

void Frame::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_Frame_rdb_5fprotocol_2fql2_2eproto.base);
  opt_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  pos_ = PROTOBUF_LONGLONG(0);
  type_ = 1;
}

Frame::~Frame() {
  // @@protoc_insertion_point(destructor:Frame)
  SharedDtor();
}

void Frame::SharedDtor() {
  opt_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void Frame::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const Frame& Frame::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_Frame_rdb_5fprotocol_2fql2_2eproto.base);
  return *internal_default_instance();
}


void Frame::Clear() {
// @@protoc_insertion_point(message_clear_start:Frame)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    opt_.ClearNonDefaultToEmptyNoArena();
  }
  if (cached_has_bits & 0x00000006u) {
    pos_ = PROTOBUF_LONGLONG(0);
    type_ = 1;
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

const char* Frame::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional .Frame.FrameType type = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::Frame_FrameType_IsValid(val))) {
            _internal_set_type(static_cast<::Frame_FrameType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else goto handle_unusual;
        continue;
      // optional int64 pos = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_pos(&has_bits);
          pos_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional string opt = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 26)) {
          auto str = _internal_mutable_opt();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "Frame.opt");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* Frame::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:Frame)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .Frame.FrameType type = 1;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      1, this->_internal_type(), target);
  }

  // optional int64 pos = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64ToArray(2, this->_internal_pos(), target);
  }

  // optional string opt = 3;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_opt().data(), static_cast<int>(this->_internal_opt().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "Frame.opt");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_opt(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Frame)
  return target;
}

size_t Frame::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Frame)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional string opt = 3;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_opt());
    }

    // optional int64 pos = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64Size(
          this->_internal_pos());
    }

    // optional .Frame.FrameType type = 1;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_type());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Frame::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:Frame)
  GOOGLE_DCHECK_NE(&from, this);
  const Frame* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<Frame>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:Frame)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:Frame)
    MergeFrom(*source);
  }
}

void Frame::MergeFrom(const Frame& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:Frame)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _has_bits_[0] |= 0x00000001u;
      opt_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.opt_);
    }
    if (cached_has_bits & 0x00000002u) {
      pos_ = from.pos_;
    }
    if (cached_has_bits & 0x00000004u) {
      type_ = from.type_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void Frame::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:Frame)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Frame::CopyFrom(const Frame& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Frame)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Frame::IsInitialized() const {
  return true;
}

void Frame::InternalSwap(Frame* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  opt_.Swap(&other->opt_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  swap(pos_, other->pos_);
  swap(type_, other->type_);
}

::PROTOBUF_NAMESPACE_ID::Metadata Frame::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void Backtrace::InitAsDefaultInstance() {
}
class Backtrace::_Internal {
 public:
  using HasBits = decltype(std::declval<Backtrace>()._has_bits_);
};

Backtrace::Backtrace()
  : ::PROTOBUF_NAMESPACE_ID::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:Backtrace)
}
Backtrace::Backtrace(const Backtrace& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_),
      frames_(from.frames_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:Backtrace)
}

void Backtrace::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_Backtrace_rdb_5fprotocol_2fql2_2eproto.base);
}

Backtrace::~Backtrace() {
  // @@protoc_insertion_point(destructor:Backtrace)
  SharedDtor();
}

void Backtrace::SharedDtor() {
}

void Backtrace::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const Backtrace& Backtrace::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_Backtrace_rdb_5fprotocol_2fql2_2eproto.base);
  return *internal_default_instance();
}


void Backtrace::Clear() {
// @@protoc_insertion_point(message_clear_start:Backtrace)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  frames_.Clear();
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

const char* Backtrace::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // repeated .Frame frames = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_frames(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* Backtrace::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:Backtrace)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .Frame frames = 1;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_frames_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, this->_internal_frames(i), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Backtrace)
  return target;
}

size_t Backtrace::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Backtrace)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .Frame frames = 1;
  total_size += 1UL * this->_internal_frames_size();
  for (const auto& msg : this->frames_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Backtrace::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:Backtrace)
  GOOGLE_DCHECK_NE(&from, this);
  const Backtrace* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<Backtrace>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:Backtrace)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:Backtrace)
    MergeFrom(*source);
  }
}

void Backtrace::MergeFrom(const Backtrace& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:Backtrace)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  frames_.MergeFrom(from.frames_);
}

void Backtrace::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:Backtrace)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Backtrace::CopyFrom(const Backtrace& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Backtrace)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Backtrace::IsInitialized() const {
  return true;
}

void Backtrace::InternalSwap(Backtrace* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  frames_.InternalSwap(&other->frames_);
}

::PROTOBUF_NAMESPACE_ID::Metadata Backtrace::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void Response::InitAsDefaultInstance() {
  ::_Response_default_instance_._instance.get_mutable()->backtrace_ = const_cast< ::Backtrace*>(
      ::Backtrace::internal_default_instance());
  ::_Response_default_instance_._instance.get_mutable()->profile_ = const_cast< ::Datum*>(
      ::Datum::internal_default_instance());
}
class Response::_Internal {
 public:
  using HasBits = decltype(std::declval<Response>()._has_bits_);
  static void set_has_type(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_error_type(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_token(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::Backtrace& backtrace(const Response* msg);
  static void set_has_backtrace(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::Datum& profile(const Response* msg);
  static void set_has_profile(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

const ::Backtrace&
Response::_Internal::backtrace(const Response* msg) {
  return *msg->backtrace_;
}
const ::Datum&
Response::_Internal::profile(const Response* msg) {
  return *msg->profile_;
}
Response::Response()
  : ::PROTOBUF_NAMESPACE_ID::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:Response)
}
Response::Response(const Response& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_),
      response_(from.response_),
      notes_(from.notes_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  if (from._internal_has_backtrace()) {
    backtrace_ = new ::Backtrace(*from.backtrace_);
  } else {
    backtrace_ = nullptr;
  }
  if (from._internal_has_profile()) {
    profile_ = new ::Datum(*from.profile_);
  } else {
    profile_ = nullptr;
  }
  ::memcpy(&token_, &from.token_,
    static_cast<size_t>(reinterpret_cast<char*>(&error_type_) -
    reinterpret_cast<char*>(&token_)) + sizeof(error_type_));
  // @@protoc_insertion_point(copy_constructor:Response)
}

void Response::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_Response_rdb_5fprotocol_2fql2_2eproto.base);
  ::memset(&backtrace_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&token_) -
      reinterpret_cast<char*>(&backtrace_)) + sizeof(token_));
  type_ = 1;
  error_type_ = 1000000;
}

Response::~Response() {
  // @@protoc_insertion_point(destructor:Response)
  SharedDtor();
}

void Response::SharedDtor() {
  if (this != internal_default_instance()) delete backtrace_;
  if (this != internal_default_instance()) delete profile_;
}

void Response::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const Response& Response::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_Response_rdb_5fprotocol_2fql2_2eproto.base);
  return *internal_default_instance();
}


void Response::Clear() {
// @@protoc_insertion_point(message_clear_start:Response)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  response_.Clear();
  notes_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(backtrace_ != nullptr);
      backtrace_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(profile_ != nullptr);
      profile_->Clear();
    }
  }
  if (cached_has_bits & 0x0000001cu) {
    token_ = PROTOBUF_LONGLONG(0);
    type_ = 1;
    error_type_ = 1000000;
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

const char* Response::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional .Response.ResponseType type = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::Response_ResponseType_IsValid(val))) {
            _internal_set_type(static_cast<::Response_ResponseType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else goto handle_unusual;
        continue;
      // optional int64 token = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_token(&has_bits);
          token_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // repeated .Datum response = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_response(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else goto handle_unusual;
        continue;
      // optional .Backtrace backtrace = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_backtrace(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .Datum profile = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_profile(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // repeated .Response.ResponseNote notes = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 48)) {
          ptr -= 1;
          do {
            ptr += 1;
            ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
            CHK_(ptr);
            if (PROTOBUF_PREDICT_TRUE(::Response_ResponseNote_IsValid(val))) {
              _internal_add_notes(static_cast<::Response_ResponseNote>(val));
            } else {
              ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(6, val, mutable_unknown_fields());
            }
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<48>(ptr));
        } else if (static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 50) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedEnumParser(_internal_mutable_notes(), ptr, ctx, ::Response_ResponseNote_IsValid, &_internal_metadata_, 6);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .Response.ErrorType error_type = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 56)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::Response_ErrorType_IsValid(val))) {
            _internal_set_error_type(static_cast<::Response_ErrorType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(7, val, mutable_unknown_fields());
          }
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* Response::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:Response)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .Response.ResponseType type = 1;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      1, this->_internal_type(), target);
  }

  // optional int64 token = 2;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64ToArray(2, this->_internal_token(), target);
  }

  // repeated .Datum response = 3;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_response_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, this->_internal_response(i), target, stream);
  }

  // optional .Backtrace backtrace = 4;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        4, _Internal::backtrace(this), target, stream);
  }

  // optional .Datum profile = 5;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        5, _Internal::profile(this), target, stream);
  }

  // repeated .Response.ResponseNote notes = 6;
  for (int i = 0, n = this->_internal_notes_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
        6, this->_internal_notes(i), target);
  }

  // optional .Response.ErrorType error_type = 7;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      7, this->_internal_error_type(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Response)
  return target;
}

size_t Response::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Response)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .Datum response = 3;
  total_size += 1UL * this->_internal_response_size();
  for (const auto& msg : this->response_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .Response.ResponseNote notes = 6;
  {
    size_t data_size = 0;
    unsigned int count = static_cast<unsigned int>(this->_internal_notes_size());for (unsigned int i = 0; i < count; i++) {
      data_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(
        this->_internal_notes(static_cast<int>(i)));
    }
    total_size += (1UL * count) + data_size;
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional .Backtrace backtrace = 4;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *backtrace_);
    }

    // optional .Datum profile = 5;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *profile_);
    }

    // optional int64 token = 2;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64Size(
          this->_internal_token());
    }

    // optional .Response.ResponseType type = 1;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_type());
    }

    // optional .Response.ErrorType error_type = 7;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_error_type());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Response::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:Response)
  GOOGLE_DCHECK_NE(&from, this);
  const Response* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<Response>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:Response)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:Response)
    MergeFrom(*source);
  }
}

void Response::MergeFrom(const Response& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:Response)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  response_.MergeFrom(from.response_);
  notes_.MergeFrom(from.notes_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_mutable_backtrace()->::Backtrace::MergeFrom(from._internal_backtrace());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_mutable_profile()->::Datum::MergeFrom(from._internal_profile());
    }
    if (cached_has_bits & 0x00000004u) {
      token_ = from.token_;
    }
    if (cached_has_bits & 0x00000008u) {
      type_ = from.type_;
    }
    if (cached_has_bits & 0x00000010u) {
      error_type_ = from.error_type_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void Response::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:Response)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Response::CopyFrom(const Response& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Response)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Response::IsInitialized() const {
  return true;
}

void Response::InternalSwap(Response* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  response_.InternalSwap(&other->response_);
  notes_.InternalSwap(&other->notes_);
  swap(backtrace_, other->backtrace_);
  swap(profile_, other->profile_);
  swap(token_, other->token_);
  swap(type_, other->type_);
  swap(error_type_, other->error_type_);
}

::PROTOBUF_NAMESPACE_ID::Metadata Response::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void Datum_AssocPair::InitAsDefaultInstance() {
  ::_Datum_AssocPair_default_instance_._instance.get_mutable()->val_ = const_cast< ::Datum*>(
      ::Datum::internal_default_instance());
}
class Datum_AssocPair::_Internal {
 public:
  using HasBits = decltype(std::declval<Datum_AssocPair>()._has_bits_);
  static void set_has_key(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::Datum& val(const Datum_AssocPair* msg);
  static void set_has_val(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

const ::Datum&
Datum_AssocPair::_Internal::val(const Datum_AssocPair* msg) {
  return *msg->val_;
}
Datum_AssocPair::Datum_AssocPair()
  : ::PROTOBUF_NAMESPACE_ID::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:Datum.AssocPair)
}
Datum_AssocPair::Datum_AssocPair(const Datum_AssocPair& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  key_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_key()) {
    key_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.key_);
  }
  if (from._internal_has_val()) {
    val_ = new ::Datum(*from.val_);
  } else {
    val_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:Datum.AssocPair)
}

void Datum_AssocPair::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_Datum_rdb_5fprotocol_2fql2_2eproto.base);
  key_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  val_ = nullptr;
}

Datum_AssocPair::~Datum_AssocPair() {
  // @@protoc_insertion_point(destructor:Datum.AssocPair)
  SharedDtor();
}

void Datum_AssocPair::SharedDtor() {
  key_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (this != internal_default_instance()) delete val_;
}

void Datum_AssocPair::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const Datum_AssocPair& Datum_AssocPair::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_Datum_rdb_5fprotocol_2fql2_2eproto.base);
  return *internal_default_instance();
}


void Datum_AssocPair::Clear() {
// @@protoc_insertion_point(message_clear_start:Datum.AssocPair)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      key_.ClearNonDefaultToEmptyNoArena();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(val_ != nullptr);
      val_->Clear();
    }
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

const char* Datum_AssocPair::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional string key = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          auto str = _internal_mutable_key();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "Datum.AssocPair.key");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .Datum val = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_val(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* Datum_AssocPair::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:Datum.AssocPair)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string key = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_key().data(), static_cast<int>(this->_internal_key().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "Datum.AssocPair.key");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_key(), target);
  }

  // optional .Datum val = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        2, _Internal::val(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Datum.AssocPair)
  return target;
}

size_t Datum_AssocPair::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Datum.AssocPair)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional string key = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_key());
    }

    // optional .Datum val = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *val_);
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Datum_AssocPair::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:Datum.AssocPair)
  GOOGLE_DCHECK_NE(&from, this);
  const Datum_AssocPair* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<Datum_AssocPair>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:Datum.AssocPair)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:Datum.AssocPair)
    MergeFrom(*source);
  }
}

void Datum_AssocPair::MergeFrom(const Datum_AssocPair& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:Datum.AssocPair)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _has_bits_[0] |= 0x00000001u;
      key_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.key_);
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_mutable_val()->::Datum::MergeFrom(from._internal_val());
    }
  }
}

void Datum_AssocPair::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:Datum.AssocPair)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Datum_AssocPair::CopyFrom(const Datum_AssocPair& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Datum.AssocPair)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Datum_AssocPair::IsInitialized() const {
  return true;
}

void Datum_AssocPair::InternalSwap(Datum_AssocPair* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  key_.Swap(&other->key_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  swap(val_, other->val_);
}

::PROTOBUF_NAMESPACE_ID::Metadata Datum_AssocPair::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void Datum::InitAsDefaultInstance() {
}
class Datum::_Internal {
 public:
  using HasBits = decltype(std::declval<Datum>()._has_bits_);
  static void set_has_type(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_r_bool(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_r_num(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_r_str(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

Datum::Datum()
  : ::PROTOBUF_NAMESPACE_ID::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:Datum)
}
Datum::Datum(const Datum& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_),
      r_array_(from.r_array_),
      r_object_(from.r_object_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  r_str_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_r_str()) {
    r_str_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.r_str_);
  }
  ::memcpy(&r_num_, &from.r_num_,
    static_cast<size_t>(reinterpret_cast<char*>(&type_) -
    reinterpret_cast<char*>(&r_num_)) + sizeof(type_));
  // @@protoc_insertion_point(copy_constructor:Datum)
}

void Datum::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_Datum_rdb_5fprotocol_2fql2_2eproto.base);
  r_str_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  ::memset(&r_num_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&r_bool_) -
      reinterpret_cast<char*>(&r_num_)) + sizeof(r_bool_));
  type_ = 1;
}

Datum::~Datum() {
  // @@protoc_insertion_point(destructor:Datum)
  SharedDtor();
}

void Datum::SharedDtor() {
  r_str_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void Datum::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const Datum& Datum::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_Datum_rdb_5fprotocol_2fql2_2eproto.base);
  return *internal_default_instance();
}


void Datum::Clear() {
// @@protoc_insertion_point(message_clear_start:Datum)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  r_array_.Clear();
  r_object_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    r_str_.ClearNonDefaultToEmptyNoArena();
  }
  if (cached_has_bits & 0x0000000eu) {
    ::memset(&r_num_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&r_bool_) -
        reinterpret_cast<char*>(&r_num_)) + sizeof(r_bool_));
    type_ = 1;
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

const char* Datum::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional .Datum.DatumType type = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::Datum_DatumType_IsValid(val))) {
            _internal_set_type(static_cast<::Datum_DatumType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else goto handle_unusual;
        continue;
      // optional bool r_bool = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_r_bool(&has_bits);
          r_bool_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional double r_num = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 25)) {
          _Internal::set_has_r_num(&has_bits);
          r_num_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else goto handle_unusual;
        continue;
      // optional string r_str = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 34)) {
          auto str = _internal_mutable_r_str();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "Datum.r_str");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // repeated .Datum r_array = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 42)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_r_array(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<42>(ptr));
        } else goto handle_unusual;
        continue;
      // repeated .Datum.AssocPair r_object = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 50)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_r_object(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<50>(ptr));
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* Datum::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:Datum)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .Datum.DatumType type = 1;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      1, this->_internal_type(), target);
  }

  // optional bool r_bool = 2;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(2, this->_internal_r_bool(), target);
  }

  // optional double r_num = 3;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(3, this->_internal_r_num(), target);
  }

  // optional string r_str = 4;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_r_str().data(), static_cast<int>(this->_internal_r_str().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "Datum.r_str");
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_r_str(), target);
  }

  // repeated .Datum r_array = 5;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_r_array_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(5, this->_internal_r_array(i), target, stream);
  }

  // repeated .Datum.AssocPair r_object = 6;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_r_object_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(6, this->_internal_r_object(i), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Datum)
  return target;
}

size_t Datum::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Datum)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .Datum r_array = 5;
  total_size += 1UL * this->_internal_r_array_size();
  for (const auto& msg : this->r_array_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .Datum.AssocPair r_object = 6;
  total_size += 1UL * this->_internal_r_object_size();
  for (const auto& msg : this->r_object_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional string r_str = 4;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_r_str());
    }

    // optional double r_num = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 8;
    }

    // optional bool r_bool = 2;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 1;
    }

    // optional .Datum.DatumType type = 1;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_type());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Datum::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:Datum)
  GOOGLE_DCHECK_NE(&from, this);
  const Datum* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<Datum>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:Datum)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:Datum)
    MergeFrom(*source);
  }
}

void Datum::MergeFrom(const Datum& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:Datum)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  r_array_.MergeFrom(from.r_array_);
  r_object_.MergeFrom(from.r_object_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _has_bits_[0] |= 0x00000001u;
      r_str_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.r_str_);
    }
    if (cached_has_bits & 0x00000002u) {
      r_num_ = from.r_num_;
    }
    if (cached_has_bits & 0x00000004u) {
      r_bool_ = from.r_bool_;
    }
    if (cached_has_bits & 0x00000008u) {
      type_ = from.type_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void Datum::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:Datum)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Datum::CopyFrom(const Datum& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Datum)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Datum::IsInitialized() const {
  return true;
}

void Datum::InternalSwap(Datum* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  r_array_.InternalSwap(&other->r_array_);
  r_object_.InternalSwap(&other->r_object_);
  r_str_.Swap(&other->r_str_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  swap(r_num_, other->r_num_);
  swap(r_bool_, other->r_bool_);
  swap(type_, other->type_);
}

::PROTOBUF_NAMESPACE_ID::Metadata Datum::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void Term_AssocPair::InitAsDefaultInstance() {
  ::_Term_AssocPair_default_instance_._instance.get_mutable()->val_ = const_cast< ::Term*>(
      ::Term::internal_default_instance());
}
class Term_AssocPair::_Internal {
 public:
  using HasBits = decltype(std::declval<Term_AssocPair>()._has_bits_);
  static void set_has_key(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::Term& val(const Term_AssocPair* msg);
  static void set_has_val(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

const ::Term&
Term_AssocPair::_Internal::val(const Term_AssocPair* msg) {
  return *msg->val_;
}
Term_AssocPair::Term_AssocPair()
  : ::PROTOBUF_NAMESPACE_ID::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:Term.AssocPair)
}
Term_AssocPair::Term_AssocPair(const Term_AssocPair& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  key_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_key()) {
    key_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.key_);
  }
  if (from._internal_has_val()) {
    val_ = new ::Term(*from.val_);
  } else {
    val_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:Term.AssocPair)
}

void Term_AssocPair::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_Term_rdb_5fprotocol_2fql2_2eproto.base);
  key_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  val_ = nullptr;
}

Term_AssocPair::~Term_AssocPair() {
  // @@protoc_insertion_point(destructor:Term.AssocPair)
  SharedDtor();
}

void Term_AssocPair::SharedDtor() {
  key_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (this != internal_default_instance()) delete val_;
}

void Term_AssocPair::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const Term_AssocPair& Term_AssocPair::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_Term_rdb_5fprotocol_2fql2_2eproto.base);
  return *internal_default_instance();
}


void Term_AssocPair::Clear() {
// @@protoc_insertion_point(message_clear_start:Term.AssocPair)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      key_.ClearNonDefaultToEmptyNoArena();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(val_ != nullptr);
      val_->Clear();
    }
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

const char* Term_AssocPair::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional string key = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          auto str = _internal_mutable_key();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "Term.AssocPair.key");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .Term val = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_val(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* Term_AssocPair::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:Term.AssocPair)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string key = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_key().data(), static_cast<int>(this->_internal_key().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "Term.AssocPair.key");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_key(), target);
  }

  // optional .Term val = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        2, _Internal::val(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Term.AssocPair)
  return target;
}

size_t Term_AssocPair::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Term.AssocPair)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional string key = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_key());
    }

    // optional .Term val = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *val_);
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Term_AssocPair::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:Term.AssocPair)
  GOOGLE_DCHECK_NE(&from, this);
  const Term_AssocPair* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<Term_AssocPair>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:Term.AssocPair)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:Term.AssocPair)
    MergeFrom(*source);
  }
}

void Term_AssocPair::MergeFrom(const Term_AssocPair& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:Term.AssocPair)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _has_bits_[0] |= 0x00000001u;
      key_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.key_);
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_mutable_val()->::Term::MergeFrom(from._internal_val());
    }
  }
}

void Term_AssocPair::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:Term.AssocPair)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Term_AssocPair::CopyFrom(const Term_AssocPair& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Term.AssocPair)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Term_AssocPair::IsInitialized() const {
  return true;
}

void Term_AssocPair::InternalSwap(Term_AssocPair* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  key_.Swap(&other->key_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  swap(val_, other->val_);
}

::PROTOBUF_NAMESPACE_ID::Metadata Term_AssocPair::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void Term::InitAsDefaultInstance() {
  ::_Term_default_instance_._instance.get_mutable()->datum_ = const_cast< ::Datum*>(
      ::Datum::internal_default_instance());
}
class Term::_Internal {
 public:
  using HasBits = decltype(std::declval<Term>()._has_bits_);
  static void set_has_type(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::Datum& datum(const Term* msg);
  static void set_has_datum(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::Datum&
Term::_Internal::datum(const Term* msg) {
  return *msg->datum_;
}
Term::Term()
  : ::PROTOBUF_NAMESPACE_ID::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:Term)
}
Term::Term(const Term& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_),
      args_(from.args_),
      optargs_(from.optargs_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  if (from._internal_has_datum()) {
    datum_ = new ::Datum(*from.datum_);
  } else {
    datum_ = nullptr;
  }
  type_ = from.type_;
  // @@protoc_insertion_point(copy_constructor:Term)
}

void Term::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_Term_rdb_5fprotocol_2fql2_2eproto.base);
  datum_ = nullptr;
  type_ = 1;
}

Term::~Term() {
  // @@protoc_insertion_point(destructor:Term)
  SharedDtor();
}

void Term::SharedDtor() {
  if (this != internal_default_instance()) delete datum_;
}

void Term::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const Term& Term::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_Term_rdb_5fprotocol_2fql2_2eproto.base);
  return *internal_default_instance();
}


void Term::Clear() {
// @@protoc_insertion_point(message_clear_start:Term)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  args_.Clear();
  optargs_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(datum_ != nullptr);
      datum_->Clear();
    }
    type_ = 1;
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

const char* Term::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional .Term.TermType type = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::Term_TermType_IsValid(val))) {
            _internal_set_type(static_cast<::Term_TermType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else goto handle_unusual;
        continue;
      // optional .Datum datum = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_datum(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // repeated .Term args = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_args(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else goto handle_unusual;
        continue;
      // repeated .Term.AssocPair optargs = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 34)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_optargs(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<34>(ptr));
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* Term::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:Term)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .Term.TermType type = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      1, this->_internal_type(), target);
  }

  // optional .Datum datum = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        2, _Internal::datum(this), target, stream);
  }

  // repeated .Term args = 3;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_args_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, this->_internal_args(i), target, stream);
  }

  // repeated .Term.AssocPair optargs = 4;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_optargs_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, this->_internal_optargs(i), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Term)
  return target;
}

size_t Term::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Term)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .Term args = 3;
  total_size += 1UL * this->_internal_args_size();
  for (const auto& msg : this->args_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .Term.AssocPair optargs = 4;
  total_size += 1UL * this->_internal_optargs_size();
  for (const auto& msg : this->optargs_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional .Datum datum = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *datum_);
    }

    // optional .Term.TermType type = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_type());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Term::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:Term)
  GOOGLE_DCHECK_NE(&from, this);
  const Term* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<Term>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:Term)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:Term)
    MergeFrom(*source);
  }
}

void Term::MergeFrom(const Term& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:Term)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  args_.MergeFrom(from.args_);
  optargs_.MergeFrom(from.optargs_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_mutable_datum()->::Datum::MergeFrom(from._internal_datum());
    }
    if (cached_has_bits & 0x00000002u) {
      type_ = from.type_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void Term::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:Term)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Term::CopyFrom(const Term& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Term)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Term::IsInitialized() const {
  return true;
}

void Term::InternalSwap(Term* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  args_.InternalSwap(&other->args_);
  optargs_.InternalSwap(&other->optargs_);
  swap(datum_, other->datum_);
  swap(type_, other->type_);
}

::PROTOBUF_NAMESPACE_ID::Metadata Term::GetMetadata() const {
  return GetMetadataStatic();
}


// @@protoc_insertion_point(namespace_scope)
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::VersionDummy* Arena::CreateMaybeMessage< ::VersionDummy >(Arena* arena) {
  return Arena::CreateInternal< ::VersionDummy >(arena);
}
template<> PROTOBUF_NOINLINE ::Query_AssocPair* Arena::CreateMaybeMessage< ::Query_AssocPair >(Arena* arena) {
  return Arena::CreateInternal< ::Query_AssocPair >(arena);
}
template<> PROTOBUF_NOINLINE ::Query* Arena::CreateMaybeMessage< ::Query >(Arena* arena) {
  return Arena::CreateInternal< ::Query >(arena);
}
template<> PROTOBUF_NOINLINE ::Frame* Arena::CreateMaybeMessage< ::Frame >(Arena* arena) {
  return Arena::CreateInternal< ::Frame >(arena);
}
template<> PROTOBUF_NOINLINE ::Backtrace* Arena::CreateMaybeMessage< ::Backtrace >(Arena* arena) {
  return Arena::CreateInternal< ::Backtrace >(arena);
}
template<> PROTOBUF_NOINLINE ::Response* Arena::CreateMaybeMessage< ::Response >(Arena* arena) {
  return Arena::CreateInternal< ::Response >(arena);
}
template<> PROTOBUF_NOINLINE ::Datum_AssocPair* Arena::CreateMaybeMessage< ::Datum_AssocPair >(Arena* arena) {
  return Arena::CreateInternal< ::Datum_AssocPair >(arena);
}
template<> PROTOBUF_NOINLINE ::Datum* Arena::CreateMaybeMessage< ::Datum >(Arena* arena) {
  return Arena::CreateInternal< ::Datum >(arena);
}
template<> PROTOBUF_NOINLINE ::Term_AssocPair* Arena::CreateMaybeMessage< ::Term_AssocPair >(Arena* arena) {
  return Arena::CreateInternal< ::Term_AssocPair >(arena);
}
template<> PROTOBUF_NOINLINE ::Term* Arena::CreateMaybeMessage< ::Term >(Arena* arena) {
  return Arena::CreateInternal< ::Term >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
