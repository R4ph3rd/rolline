// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: rdb_protocol/ql2.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_rdb_5fprotocol_2fql2_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_rdb_5fprotocol_2fql2_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3011000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3011002 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_rdb_5fprotocol_2fql2_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_rdb_5fprotocol_2fql2_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxillaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[10]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_rdb_5fprotocol_2fql2_2eproto;
class Backtrace;
class BacktraceDefaultTypeInternal;
extern BacktraceDefaultTypeInternal _Backtrace_default_instance_;
class Datum;
class DatumDefaultTypeInternal;
extern DatumDefaultTypeInternal _Datum_default_instance_;
class Datum_AssocPair;
class Datum_AssocPairDefaultTypeInternal;
extern Datum_AssocPairDefaultTypeInternal _Datum_AssocPair_default_instance_;
class Frame;
class FrameDefaultTypeInternal;
extern FrameDefaultTypeInternal _Frame_default_instance_;
class Query;
class QueryDefaultTypeInternal;
extern QueryDefaultTypeInternal _Query_default_instance_;
class Query_AssocPair;
class Query_AssocPairDefaultTypeInternal;
extern Query_AssocPairDefaultTypeInternal _Query_AssocPair_default_instance_;
class Response;
class ResponseDefaultTypeInternal;
extern ResponseDefaultTypeInternal _Response_default_instance_;
class Term;
class TermDefaultTypeInternal;
extern TermDefaultTypeInternal _Term_default_instance_;
class Term_AssocPair;
class Term_AssocPairDefaultTypeInternal;
extern Term_AssocPairDefaultTypeInternal _Term_AssocPair_default_instance_;
class VersionDummy;
class VersionDummyDefaultTypeInternal;
extern VersionDummyDefaultTypeInternal _VersionDummy_default_instance_;
PROTOBUF_NAMESPACE_OPEN
template<> ::Backtrace* Arena::CreateMaybeMessage<::Backtrace>(Arena*);
template<> ::Datum* Arena::CreateMaybeMessage<::Datum>(Arena*);
template<> ::Datum_AssocPair* Arena::CreateMaybeMessage<::Datum_AssocPair>(Arena*);
template<> ::Frame* Arena::CreateMaybeMessage<::Frame>(Arena*);
template<> ::Query* Arena::CreateMaybeMessage<::Query>(Arena*);
template<> ::Query_AssocPair* Arena::CreateMaybeMessage<::Query_AssocPair>(Arena*);
template<> ::Response* Arena::CreateMaybeMessage<::Response>(Arena*);
template<> ::Term* Arena::CreateMaybeMessage<::Term>(Arena*);
template<> ::Term_AssocPair* Arena::CreateMaybeMessage<::Term_AssocPair>(Arena*);
template<> ::VersionDummy* Arena::CreateMaybeMessage<::VersionDummy>(Arena*);
PROTOBUF_NAMESPACE_CLOSE

enum VersionDummy_Version : int {
  VersionDummy_Version_V0_1 = 1063369270,
  VersionDummy_Version_V0_2 = 1915781601,
  VersionDummy_Version_V0_3 = 1601562686,
  VersionDummy_Version_V0_4 = 1074539808,
  VersionDummy_Version_V1_0 = 885177795
};
bool VersionDummy_Version_IsValid(int value);
constexpr VersionDummy_Version VersionDummy_Version_Version_MIN = VersionDummy_Version_V1_0;
constexpr VersionDummy_Version VersionDummy_Version_Version_MAX = VersionDummy_Version_V0_2;
constexpr int VersionDummy_Version_Version_ARRAYSIZE = VersionDummy_Version_Version_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* VersionDummy_Version_descriptor();
template<typename T>
inline const std::string& VersionDummy_Version_Name(T enum_t_value) {
  static_assert(::std::is_same<T, VersionDummy_Version>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function VersionDummy_Version_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    VersionDummy_Version_descriptor(), enum_t_value);
}
inline bool VersionDummy_Version_Parse(
    const std::string& name, VersionDummy_Version* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<VersionDummy_Version>(
    VersionDummy_Version_descriptor(), name, value);
}
enum VersionDummy_Protocol : int {
  VersionDummy_Protocol_PROTOBUF = 656407617,
  VersionDummy_Protocol_JSON = 2120839367
};
bool VersionDummy_Protocol_IsValid(int value);
constexpr VersionDummy_Protocol VersionDummy_Protocol_Protocol_MIN = VersionDummy_Protocol_PROTOBUF;
constexpr VersionDummy_Protocol VersionDummy_Protocol_Protocol_MAX = VersionDummy_Protocol_JSON;
constexpr int VersionDummy_Protocol_Protocol_ARRAYSIZE = VersionDummy_Protocol_Protocol_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* VersionDummy_Protocol_descriptor();
template<typename T>
inline const std::string& VersionDummy_Protocol_Name(T enum_t_value) {
  static_assert(::std::is_same<T, VersionDummy_Protocol>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function VersionDummy_Protocol_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    VersionDummy_Protocol_descriptor(), enum_t_value);
}
inline bool VersionDummy_Protocol_Parse(
    const std::string& name, VersionDummy_Protocol* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<VersionDummy_Protocol>(
    VersionDummy_Protocol_descriptor(), name, value);
}
enum Query_QueryType : int {
  Query_QueryType_START = 1,
  Query_QueryType_CONTINUE = 2,
  Query_QueryType_STOP = 3,
  Query_QueryType_NOREPLY_WAIT = 4,
  Query_QueryType_SERVER_INFO = 5
};
bool Query_QueryType_IsValid(int value);
constexpr Query_QueryType Query_QueryType_QueryType_MIN = Query_QueryType_START;
constexpr Query_QueryType Query_QueryType_QueryType_MAX = Query_QueryType_SERVER_INFO;
constexpr int Query_QueryType_QueryType_ARRAYSIZE = Query_QueryType_QueryType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Query_QueryType_descriptor();
template<typename T>
inline const std::string& Query_QueryType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Query_QueryType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Query_QueryType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Query_QueryType_descriptor(), enum_t_value);
}
inline bool Query_QueryType_Parse(
    const std::string& name, Query_QueryType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Query_QueryType>(
    Query_QueryType_descriptor(), name, value);
}
enum Frame_FrameType : int {
  Frame_FrameType_POS = 1,
  Frame_FrameType_OPT = 2
};
bool Frame_FrameType_IsValid(int value);
constexpr Frame_FrameType Frame_FrameType_FrameType_MIN = Frame_FrameType_POS;
constexpr Frame_FrameType Frame_FrameType_FrameType_MAX = Frame_FrameType_OPT;
constexpr int Frame_FrameType_FrameType_ARRAYSIZE = Frame_FrameType_FrameType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Frame_FrameType_descriptor();
template<typename T>
inline const std::string& Frame_FrameType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Frame_FrameType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Frame_FrameType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Frame_FrameType_descriptor(), enum_t_value);
}
inline bool Frame_FrameType_Parse(
    const std::string& name, Frame_FrameType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Frame_FrameType>(
    Frame_FrameType_descriptor(), name, value);
}
enum Response_ResponseType : int {
  Response_ResponseType_SUCCESS_ATOM = 1,
  Response_ResponseType_SUCCESS_SEQUENCE = 2,
  Response_ResponseType_SUCCESS_PARTIAL = 3,
  Response_ResponseType_WAIT_COMPLETE = 4,
  Response_ResponseType_SERVER_INFO = 5,
  Response_ResponseType_CLIENT_ERROR = 16,
  Response_ResponseType_COMPILE_ERROR = 17,
  Response_ResponseType_RUNTIME_ERROR = 18
};
bool Response_ResponseType_IsValid(int value);
constexpr Response_ResponseType Response_ResponseType_ResponseType_MIN = Response_ResponseType_SUCCESS_ATOM;
constexpr Response_ResponseType Response_ResponseType_ResponseType_MAX = Response_ResponseType_RUNTIME_ERROR;
constexpr int Response_ResponseType_ResponseType_ARRAYSIZE = Response_ResponseType_ResponseType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Response_ResponseType_descriptor();
template<typename T>
inline const std::string& Response_ResponseType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Response_ResponseType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Response_ResponseType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Response_ResponseType_descriptor(), enum_t_value);
}
inline bool Response_ResponseType_Parse(
    const std::string& name, Response_ResponseType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Response_ResponseType>(
    Response_ResponseType_descriptor(), name, value);
}
enum Response_ErrorType : int {
  Response_ErrorType_INTERNAL = 1000000,
  Response_ErrorType_RESOURCE_LIMIT = 2000000,
  Response_ErrorType_QUERY_LOGIC = 3000000,
  Response_ErrorType_NON_EXISTENCE = 3100000,
  Response_ErrorType_OP_FAILED = 4100000,
  Response_ErrorType_OP_INDETERMINATE = 4200000,
  Response_ErrorType_USER = 5000000,
  Response_ErrorType_PERMISSION_ERROR = 6000000
};
bool Response_ErrorType_IsValid(int value);
constexpr Response_ErrorType Response_ErrorType_ErrorType_MIN = Response_ErrorType_INTERNAL;
constexpr Response_ErrorType Response_ErrorType_ErrorType_MAX = Response_ErrorType_PERMISSION_ERROR;
constexpr int Response_ErrorType_ErrorType_ARRAYSIZE = Response_ErrorType_ErrorType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Response_ErrorType_descriptor();
template<typename T>
inline const std::string& Response_ErrorType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Response_ErrorType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Response_ErrorType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Response_ErrorType_descriptor(), enum_t_value);
}
inline bool Response_ErrorType_Parse(
    const std::string& name, Response_ErrorType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Response_ErrorType>(
    Response_ErrorType_descriptor(), name, value);
}
enum Response_ResponseNote : int {
  Response_ResponseNote_SEQUENCE_FEED = 1,
  Response_ResponseNote_ATOM_FEED = 2,
  Response_ResponseNote_ORDER_BY_LIMIT_FEED = 3,
  Response_ResponseNote_UNIONED_FEED = 4,
  Response_ResponseNote_INCLUDES_STATES = 5
};
bool Response_ResponseNote_IsValid(int value);
constexpr Response_ResponseNote Response_ResponseNote_ResponseNote_MIN = Response_ResponseNote_SEQUENCE_FEED;
constexpr Response_ResponseNote Response_ResponseNote_ResponseNote_MAX = Response_ResponseNote_INCLUDES_STATES;
constexpr int Response_ResponseNote_ResponseNote_ARRAYSIZE = Response_ResponseNote_ResponseNote_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Response_ResponseNote_descriptor();
template<typename T>
inline const std::string& Response_ResponseNote_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Response_ResponseNote>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Response_ResponseNote_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Response_ResponseNote_descriptor(), enum_t_value);
}
inline bool Response_ResponseNote_Parse(
    const std::string& name, Response_ResponseNote* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Response_ResponseNote>(
    Response_ResponseNote_descriptor(), name, value);
}
enum Datum_DatumType : int {
  Datum_DatumType_R_NULL = 1,
  Datum_DatumType_R_BOOL = 2,
  Datum_DatumType_R_NUM = 3,
  Datum_DatumType_R_STR = 4,
  Datum_DatumType_R_ARRAY = 5,
  Datum_DatumType_R_OBJECT = 6,
  Datum_DatumType_R_JSON = 7
};
bool Datum_DatumType_IsValid(int value);
constexpr Datum_DatumType Datum_DatumType_DatumType_MIN = Datum_DatumType_R_NULL;
constexpr Datum_DatumType Datum_DatumType_DatumType_MAX = Datum_DatumType_R_JSON;
constexpr int Datum_DatumType_DatumType_ARRAYSIZE = Datum_DatumType_DatumType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Datum_DatumType_descriptor();
template<typename T>
inline const std::string& Datum_DatumType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Datum_DatumType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Datum_DatumType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Datum_DatumType_descriptor(), enum_t_value);
}
inline bool Datum_DatumType_Parse(
    const std::string& name, Datum_DatumType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Datum_DatumType>(
    Datum_DatumType_descriptor(), name, value);
}
enum Term_TermType : int {
  Term_TermType_DATUM = 1,
  Term_TermType_MAKE_ARRAY = 2,
  Term_TermType_MAKE_OBJ = 3,
  Term_TermType_VAR = 10,
  Term_TermType_JAVASCRIPT = 11,
  Term_TermType_UUID = 169,
  Term_TermType_HTTP = 153,
  Term_TermType_ERROR = 12,
  Term_TermType_IMPLICIT_VAR = 13,
  Term_TermType_DB = 14,
  Term_TermType_TABLE = 15,
  Term_TermType_GET = 16,
  Term_TermType_GET_ALL = 78,
  Term_TermType_EQ = 17,
  Term_TermType_NE = 18,
  Term_TermType_LT = 19,
  Term_TermType_LE = 20,
  Term_TermType_GT = 21,
  Term_TermType_GE = 22,
  Term_TermType_NOT = 23,
  Term_TermType_ADD = 24,
  Term_TermType_SUB = 25,
  Term_TermType_MUL = 26,
  Term_TermType_DIV = 27,
  Term_TermType_MOD = 28,
  Term_TermType_FLOOR = 183,
  Term_TermType_CEIL = 184,
  Term_TermType_ROUND = 185,
  Term_TermType_APPEND = 29,
  Term_TermType_PREPEND = 80,
  Term_TermType_DIFFERENCE = 95,
  Term_TermType_SET_INSERT = 88,
  Term_TermType_SET_INTERSECTION = 89,
  Term_TermType_SET_UNION = 90,
  Term_TermType_SET_DIFFERENCE = 91,
  Term_TermType_SLICE = 30,
  Term_TermType_SKIP = 70,
  Term_TermType_LIMIT = 71,
  Term_TermType_OFFSETS_OF = 87,
  Term_TermType_CONTAINS = 93,
  Term_TermType_GET_FIELD = 31,
  Term_TermType_KEYS = 94,
  Term_TermType_VALUES = 186,
  Term_TermType_OBJECT = 143,
  Term_TermType_HAS_FIELDS = 32,
  Term_TermType_WITH_FIELDS = 96,
  Term_TermType_PLUCK = 33,
  Term_TermType_WITHOUT = 34,
  Term_TermType_MERGE = 35,
  Term_TermType_BETWEEN_DEPRECATED = 36,
  Term_TermType_BETWEEN = 182,
  Term_TermType_REDUCE = 37,
  Term_TermType_MAP = 38,
  Term_TermType_FOLD = 187,
  Term_TermType_FILTER = 39,
  Term_TermType_CONCAT_MAP = 40,
  Term_TermType_ORDER_BY = 41,
  Term_TermType_DISTINCT = 42,
  Term_TermType_COUNT = 43,
  Term_TermType_IS_EMPTY = 86,
  Term_TermType_UNION = 44,
  Term_TermType_NTH = 45,
  Term_TermType_BRACKET = 170,
  Term_TermType_INNER_JOIN = 48,
  Term_TermType_OUTER_JOIN = 49,
  Term_TermType_EQ_JOIN = 50,
  Term_TermType_ZIP = 72,
  Term_TermType_RANGE = 173,
  Term_TermType_INSERT_AT = 82,
  Term_TermType_DELETE_AT = 83,
  Term_TermType_CHANGE_AT = 84,
  Term_TermType_SPLICE_AT = 85,
  Term_TermType_COERCE_TO = 51,
  Term_TermType_TYPE_OF = 52,
  Term_TermType_UPDATE = 53,
  Term_TermType_DELETE = 54,
  Term_TermType_REPLACE = 55,
  Term_TermType_INSERT = 56,
  Term_TermType_DB_CREATE = 57,
  Term_TermType_DB_DROP = 58,
  Term_TermType_DB_LIST = 59,
  Term_TermType_TABLE_CREATE = 60,
  Term_TermType_TABLE_DROP = 61,
  Term_TermType_TABLE_LIST = 62,
  Term_TermType_CONFIG = 174,
  Term_TermType_STATUS = 175,
  Term_TermType_WAIT = 177,
  Term_TermType_RECONFIGURE = 176,
  Term_TermType_REBALANCE = 179,
  Term_TermType_SYNC = 138,
  Term_TermType_GRANT = 188,
  Term_TermType_INDEX_CREATE = 75,
  Term_TermType_INDEX_DROP = 76,
  Term_TermType_INDEX_LIST = 77,
  Term_TermType_INDEX_STATUS = 139,
  Term_TermType_INDEX_WAIT = 140,
  Term_TermType_INDEX_RENAME = 156,
  Term_TermType_SET_WRITE_HOOK = 189,
  Term_TermType_GET_WRITE_HOOK = 190,
  Term_TermType_FUNCALL = 64,
  Term_TermType_BRANCH = 65,
  Term_TermType_OR = 66,
  Term_TermType_AND = 67,
  Term_TermType_FOR_EACH = 68,
  Term_TermType_FUNC = 69,
  Term_TermType_ASC = 73,
  Term_TermType_DESC = 74,
  Term_TermType_INFO = 79,
  Term_TermType_MATCH = 97,
  Term_TermType_UPCASE = 141,
  Term_TermType_DOWNCASE = 142,
  Term_TermType_SAMPLE = 81,
  Term_TermType_DEFAULT = 92,
  Term_TermType_JSON = 98,
  Term_TermType_ISO8601 = 99,
  Term_TermType_TO_ISO8601 = 100,
  Term_TermType_EPOCH_TIME = 101,
  Term_TermType_TO_EPOCH_TIME = 102,
  Term_TermType_NOW = 103,
  Term_TermType_IN_TIMEZONE = 104,
  Term_TermType_DURING = 105,
  Term_TermType_DATE = 106,
  Term_TermType_TIME_OF_DAY = 126,
  Term_TermType_TIMEZONE = 127,
  Term_TermType_YEAR = 128,
  Term_TermType_MONTH = 129,
  Term_TermType_DAY = 130,
  Term_TermType_DAY_OF_WEEK = 131,
  Term_TermType_DAY_OF_YEAR = 132,
  Term_TermType_HOURS = 133,
  Term_TermType_MINUTES = 134,
  Term_TermType_SECONDS = 135,
  Term_TermType_TIME = 136,
  Term_TermType_MONDAY = 107,
  Term_TermType_TUESDAY = 108,
  Term_TermType_WEDNESDAY = 109,
  Term_TermType_THURSDAY = 110,
  Term_TermType_FRIDAY = 111,
  Term_TermType_SATURDAY = 112,
  Term_TermType_SUNDAY = 113,
  Term_TermType_JANUARY = 114,
  Term_TermType_FEBRUARY = 115,
  Term_TermType_MARCH = 116,
  Term_TermType_APRIL = 117,
  Term_TermType_MAY = 118,
  Term_TermType_JUNE = 119,
  Term_TermType_JULY = 120,
  Term_TermType_AUGUST = 121,
  Term_TermType_SEPTEMBER = 122,
  Term_TermType_OCTOBER = 123,
  Term_TermType_NOVEMBER = 124,
  Term_TermType_DECEMBER = 125,
  Term_TermType_LITERAL = 137,
  Term_TermType_GROUP = 144,
  Term_TermType_SUM = 145,
  Term_TermType_AVG = 146,
  Term_TermType_MIN = 147,
  Term_TermType_MAX = 148,
  Term_TermType_SPLIT = 149,
  Term_TermType_UNGROUP = 150,
  Term_TermType_RANDOM = 151,
  Term_TermType_CHANGES = 152,
  Term_TermType_ARGS = 154,
  Term_TermType_BINARY = 155,
  Term_TermType_GEOJSON = 157,
  Term_TermType_TO_GEOJSON = 158,
  Term_TermType_POINT = 159,
  Term_TermType_LINE = 160,
  Term_TermType_POLYGON = 161,
  Term_TermType_DISTANCE = 162,
  Term_TermType_INTERSECTS = 163,
  Term_TermType_INCLUDES = 164,
  Term_TermType_CIRCLE = 165,
  Term_TermType_GET_INTERSECTING = 166,
  Term_TermType_FILL = 167,
  Term_TermType_GET_NEAREST = 168,
  Term_TermType_POLYGON_SUB = 171,
  Term_TermType_TO_JSON_STRING = 172,
  Term_TermType_MINVAL = 180,
  Term_TermType_MAXVAL = 181,
  Term_TermType_BIT_AND = 191,
  Term_TermType_BIT_OR = 192,
  Term_TermType_BIT_XOR = 193,
  Term_TermType_BIT_NOT = 194,
  Term_TermType_BIT_SAL = 195,
  Term_TermType_BIT_SAR = 196
};
bool Term_TermType_IsValid(int value);
constexpr Term_TermType Term_TermType_TermType_MIN = Term_TermType_DATUM;
constexpr Term_TermType Term_TermType_TermType_MAX = Term_TermType_BIT_SAR;
constexpr int Term_TermType_TermType_ARRAYSIZE = Term_TermType_TermType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Term_TermType_descriptor();
template<typename T>
inline const std::string& Term_TermType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Term_TermType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Term_TermType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Term_TermType_descriptor(), enum_t_value);
}
inline bool Term_TermType_Parse(
    const std::string& name, Term_TermType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Term_TermType>(
    Term_TermType_descriptor(), name, value);
}
// ===================================================================

class VersionDummy :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:VersionDummy) */ {
 public:
  VersionDummy();
  virtual ~VersionDummy();

  VersionDummy(const VersionDummy& from);
  VersionDummy(VersionDummy&& from) noexcept
    : VersionDummy() {
    *this = ::std::move(from);
  }

  inline VersionDummy& operator=(const VersionDummy& from) {
    CopyFrom(from);
    return *this;
  }
  inline VersionDummy& operator=(VersionDummy&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const VersionDummy& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const VersionDummy* internal_default_instance() {
    return reinterpret_cast<const VersionDummy*>(
               &_VersionDummy_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(VersionDummy& a, VersionDummy& b) {
    a.Swap(&b);
  }
  inline void Swap(VersionDummy* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline VersionDummy* New() const final {
    return CreateMaybeMessage<VersionDummy>(nullptr);
  }

  VersionDummy* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<VersionDummy>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const VersionDummy& from);
  void MergeFrom(const VersionDummy& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(VersionDummy* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "VersionDummy";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_rdb_5fprotocol_2fql2_2eproto);
    return ::descriptor_table_rdb_5fprotocol_2fql2_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef VersionDummy_Version Version;
  static constexpr Version V0_1 =
    VersionDummy_Version_V0_1;
  static constexpr Version V0_2 =
    VersionDummy_Version_V0_2;
  static constexpr Version V0_3 =
    VersionDummy_Version_V0_3;
  static constexpr Version V0_4 =
    VersionDummy_Version_V0_4;
  static constexpr Version V1_0 =
    VersionDummy_Version_V1_0;
  static inline bool Version_IsValid(int value) {
    return VersionDummy_Version_IsValid(value);
  }
  static constexpr Version Version_MIN =
    VersionDummy_Version_Version_MIN;
  static constexpr Version Version_MAX =
    VersionDummy_Version_Version_MAX;
  static constexpr int Version_ARRAYSIZE =
    VersionDummy_Version_Version_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Version_descriptor() {
    return VersionDummy_Version_descriptor();
  }
  template<typename T>
  static inline const std::string& Version_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Version>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Version_Name.");
    return VersionDummy_Version_Name(enum_t_value);
  }
  static inline bool Version_Parse(const std::string& name,
      Version* value) {
    return VersionDummy_Version_Parse(name, value);
  }

  typedef VersionDummy_Protocol Protocol;
  static constexpr Protocol PROTOBUF =
    VersionDummy_Protocol_PROTOBUF;
  static constexpr Protocol JSON =
    VersionDummy_Protocol_JSON;
  static inline bool Protocol_IsValid(int value) {
    return VersionDummy_Protocol_IsValid(value);
  }
  static constexpr Protocol Protocol_MIN =
    VersionDummy_Protocol_Protocol_MIN;
  static constexpr Protocol Protocol_MAX =
    VersionDummy_Protocol_Protocol_MAX;
  static constexpr int Protocol_ARRAYSIZE =
    VersionDummy_Protocol_Protocol_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Protocol_descriptor() {
    return VersionDummy_Protocol_descriptor();
  }
  template<typename T>
  static inline const std::string& Protocol_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Protocol>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Protocol_Name.");
    return VersionDummy_Protocol_Name(enum_t_value);
  }
  static inline bool Protocol_Parse(const std::string& name,
      Protocol* value) {
    return VersionDummy_Protocol_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:VersionDummy)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_rdb_5fprotocol_2fql2_2eproto;
};
// -------------------------------------------------------------------

class Query_AssocPair :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Query.AssocPair) */ {
 public:
  Query_AssocPair();
  virtual ~Query_AssocPair();

  Query_AssocPair(const Query_AssocPair& from);
  Query_AssocPair(Query_AssocPair&& from) noexcept
    : Query_AssocPair() {
    *this = ::std::move(from);
  }

  inline Query_AssocPair& operator=(const Query_AssocPair& from) {
    CopyFrom(from);
    return *this;
  }
  inline Query_AssocPair& operator=(Query_AssocPair&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Query_AssocPair& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Query_AssocPair* internal_default_instance() {
    return reinterpret_cast<const Query_AssocPair*>(
               &_Query_AssocPair_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(Query_AssocPair& a, Query_AssocPair& b) {
    a.Swap(&b);
  }
  inline void Swap(Query_AssocPair* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Query_AssocPair* New() const final {
    return CreateMaybeMessage<Query_AssocPair>(nullptr);
  }

  Query_AssocPair* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Query_AssocPair>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Query_AssocPair& from);
  void MergeFrom(const Query_AssocPair& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Query_AssocPair* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Query.AssocPair";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_rdb_5fprotocol_2fql2_2eproto);
    return ::descriptor_table_rdb_5fprotocol_2fql2_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kKeyFieldNumber = 1,
    kValFieldNumber = 2,
  };
  // optional string key = 1;
  bool has_key() const;
  private:
  bool _internal_has_key() const;
  public:
  void clear_key();
  const std::string& key() const;
  void set_key(const std::string& value);
  void set_key(std::string&& value);
  void set_key(const char* value);
  void set_key(const char* value, size_t size);
  std::string* mutable_key();
  std::string* release_key();
  void set_allocated_key(std::string* key);
  private:
  const std::string& _internal_key() const;
  void _internal_set_key(const std::string& value);
  std::string* _internal_mutable_key();
  public:

  // optional .Term val = 2;
  bool has_val() const;
  private:
  bool _internal_has_val() const;
  public:
  void clear_val();
  const ::Term& val() const;
  ::Term* release_val();
  ::Term* mutable_val();
  void set_allocated_val(::Term* val);
  private:
  const ::Term& _internal_val() const;
  ::Term* _internal_mutable_val();
  public:

  // @@protoc_insertion_point(class_scope:Query.AssocPair)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr key_;
  ::Term* val_;
  friend struct ::TableStruct_rdb_5fprotocol_2fql2_2eproto;
};
// -------------------------------------------------------------------

class Query :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Query) */ {
 public:
  Query();
  virtual ~Query();

  Query(const Query& from);
  Query(Query&& from) noexcept
    : Query() {
    *this = ::std::move(from);
  }

  inline Query& operator=(const Query& from) {
    CopyFrom(from);
    return *this;
  }
  inline Query& operator=(Query&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Query& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Query* internal_default_instance() {
    return reinterpret_cast<const Query*>(
               &_Query_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(Query& a, Query& b) {
    a.Swap(&b);
  }
  inline void Swap(Query* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Query* New() const final {
    return CreateMaybeMessage<Query>(nullptr);
  }

  Query* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Query>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Query& from);
  void MergeFrom(const Query& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Query* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Query";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_rdb_5fprotocol_2fql2_2eproto);
    return ::descriptor_table_rdb_5fprotocol_2fql2_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef Query_AssocPair AssocPair;

  typedef Query_QueryType QueryType;
  static constexpr QueryType START =
    Query_QueryType_START;
  static constexpr QueryType CONTINUE =
    Query_QueryType_CONTINUE;
  static constexpr QueryType STOP =
    Query_QueryType_STOP;
  static constexpr QueryType NOREPLY_WAIT =
    Query_QueryType_NOREPLY_WAIT;
  static constexpr QueryType SERVER_INFO =
    Query_QueryType_SERVER_INFO;
  static inline bool QueryType_IsValid(int value) {
    return Query_QueryType_IsValid(value);
  }
  static constexpr QueryType QueryType_MIN =
    Query_QueryType_QueryType_MIN;
  static constexpr QueryType QueryType_MAX =
    Query_QueryType_QueryType_MAX;
  static constexpr int QueryType_ARRAYSIZE =
    Query_QueryType_QueryType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  QueryType_descriptor() {
    return Query_QueryType_descriptor();
  }
  template<typename T>
  static inline const std::string& QueryType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, QueryType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function QueryType_Name.");
    return Query_QueryType_Name(enum_t_value);
  }
  static inline bool QueryType_Parse(const std::string& name,
      QueryType* value) {
    return Query_QueryType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kGlobalOptargsFieldNumber = 6,
    kQueryFieldNumber = 2,
    kTokenFieldNumber = 3,
    kOBSOLETENoreplyFieldNumber = 4,
    kAcceptsRJsonFieldNumber = 5,
    kTypeFieldNumber = 1,
  };
  // repeated .Query.AssocPair global_optargs = 6;
  int global_optargs_size() const;
  private:
  int _internal_global_optargs_size() const;
  public:
  void clear_global_optargs();
  ::Query_AssocPair* mutable_global_optargs(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Query_AssocPair >*
      mutable_global_optargs();
  private:
  const ::Query_AssocPair& _internal_global_optargs(int index) const;
  ::Query_AssocPair* _internal_add_global_optargs();
  public:
  const ::Query_AssocPair& global_optargs(int index) const;
  ::Query_AssocPair* add_global_optargs();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Query_AssocPair >&
      global_optargs() const;

  // optional .Term query = 2;
  bool has_query() const;
  private:
  bool _internal_has_query() const;
  public:
  void clear_query();
  const ::Term& query() const;
  ::Term* release_query();
  ::Term* mutable_query();
  void set_allocated_query(::Term* query);
  private:
  const ::Term& _internal_query() const;
  ::Term* _internal_mutable_query();
  public:

  // optional int64 token = 3;
  bool has_token() const;
  private:
  bool _internal_has_token() const;
  public:
  void clear_token();
  ::PROTOBUF_NAMESPACE_ID::int64 token() const;
  void set_token(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_token() const;
  void _internal_set_token(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // optional bool OBSOLETE_noreply = 4 [default = false];
  bool has_obsolete_noreply() const;
  private:
  bool _internal_has_obsolete_noreply() const;
  public:
  void clear_obsolete_noreply();
  bool obsolete_noreply() const;
  void set_obsolete_noreply(bool value);
  private:
  bool _internal_obsolete_noreply() const;
  void _internal_set_obsolete_noreply(bool value);
  public:

  // optional bool accepts_r_json = 5 [default = false];
  bool has_accepts_r_json() const;
  private:
  bool _internal_has_accepts_r_json() const;
  public:
  void clear_accepts_r_json();
  bool accepts_r_json() const;
  void set_accepts_r_json(bool value);
  private:
  bool _internal_accepts_r_json() const;
  void _internal_set_accepts_r_json(bool value);
  public:

  // optional .Query.QueryType type = 1;
  bool has_type() const;
  private:
  bool _internal_has_type() const;
  public:
  void clear_type();
  ::Query_QueryType type() const;
  void set_type(::Query_QueryType value);
  private:
  ::Query_QueryType _internal_type() const;
  void _internal_set_type(::Query_QueryType value);
  public:

  // @@protoc_insertion_point(class_scope:Query)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Query_AssocPair > global_optargs_;
  ::Term* query_;
  ::PROTOBUF_NAMESPACE_ID::int64 token_;
  bool obsolete_noreply_;
  bool accepts_r_json_;
  int type_;
  friend struct ::TableStruct_rdb_5fprotocol_2fql2_2eproto;
};
// -------------------------------------------------------------------

class Frame :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Frame) */ {
 public:
  Frame();
  virtual ~Frame();

  Frame(const Frame& from);
  Frame(Frame&& from) noexcept
    : Frame() {
    *this = ::std::move(from);
  }

  inline Frame& operator=(const Frame& from) {
    CopyFrom(from);
    return *this;
  }
  inline Frame& operator=(Frame&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Frame& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Frame* internal_default_instance() {
    return reinterpret_cast<const Frame*>(
               &_Frame_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(Frame& a, Frame& b) {
    a.Swap(&b);
  }
  inline void Swap(Frame* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Frame* New() const final {
    return CreateMaybeMessage<Frame>(nullptr);
  }

  Frame* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Frame>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Frame& from);
  void MergeFrom(const Frame& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Frame* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Frame";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_rdb_5fprotocol_2fql2_2eproto);
    return ::descriptor_table_rdb_5fprotocol_2fql2_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef Frame_FrameType FrameType;
  static constexpr FrameType POS =
    Frame_FrameType_POS;
  static constexpr FrameType OPT =
    Frame_FrameType_OPT;
  static inline bool FrameType_IsValid(int value) {
    return Frame_FrameType_IsValid(value);
  }
  static constexpr FrameType FrameType_MIN =
    Frame_FrameType_FrameType_MIN;
  static constexpr FrameType FrameType_MAX =
    Frame_FrameType_FrameType_MAX;
  static constexpr int FrameType_ARRAYSIZE =
    Frame_FrameType_FrameType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  FrameType_descriptor() {
    return Frame_FrameType_descriptor();
  }
  template<typename T>
  static inline const std::string& FrameType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, FrameType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function FrameType_Name.");
    return Frame_FrameType_Name(enum_t_value);
  }
  static inline bool FrameType_Parse(const std::string& name,
      FrameType* value) {
    return Frame_FrameType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kOptFieldNumber = 3,
    kPosFieldNumber = 2,
    kTypeFieldNumber = 1,
  };
  // optional string opt = 3;
  bool has_opt() const;
  private:
  bool _internal_has_opt() const;
  public:
  void clear_opt();
  const std::string& opt() const;
  void set_opt(const std::string& value);
  void set_opt(std::string&& value);
  void set_opt(const char* value);
  void set_opt(const char* value, size_t size);
  std::string* mutable_opt();
  std::string* release_opt();
  void set_allocated_opt(std::string* opt);
  private:
  const std::string& _internal_opt() const;
  void _internal_set_opt(const std::string& value);
  std::string* _internal_mutable_opt();
  public:

  // optional int64 pos = 2;
  bool has_pos() const;
  private:
  bool _internal_has_pos() const;
  public:
  void clear_pos();
  ::PROTOBUF_NAMESPACE_ID::int64 pos() const;
  void set_pos(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_pos() const;
  void _internal_set_pos(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // optional .Frame.FrameType type = 1;
  bool has_type() const;
  private:
  bool _internal_has_type() const;
  public:
  void clear_type();
  ::Frame_FrameType type() const;
  void set_type(::Frame_FrameType value);
  private:
  ::Frame_FrameType _internal_type() const;
  void _internal_set_type(::Frame_FrameType value);
  public:

  // @@protoc_insertion_point(class_scope:Frame)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr opt_;
  ::PROTOBUF_NAMESPACE_ID::int64 pos_;
  int type_;
  friend struct ::TableStruct_rdb_5fprotocol_2fql2_2eproto;
};
// -------------------------------------------------------------------

class Backtrace :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Backtrace) */ {
 public:
  Backtrace();
  virtual ~Backtrace();

  Backtrace(const Backtrace& from);
  Backtrace(Backtrace&& from) noexcept
    : Backtrace() {
    *this = ::std::move(from);
  }

  inline Backtrace& operator=(const Backtrace& from) {
    CopyFrom(from);
    return *this;
  }
  inline Backtrace& operator=(Backtrace&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Backtrace& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Backtrace* internal_default_instance() {
    return reinterpret_cast<const Backtrace*>(
               &_Backtrace_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(Backtrace& a, Backtrace& b) {
    a.Swap(&b);
  }
  inline void Swap(Backtrace* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Backtrace* New() const final {
    return CreateMaybeMessage<Backtrace>(nullptr);
  }

  Backtrace* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Backtrace>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Backtrace& from);
  void MergeFrom(const Backtrace& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Backtrace* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Backtrace";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_rdb_5fprotocol_2fql2_2eproto);
    return ::descriptor_table_rdb_5fprotocol_2fql2_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFramesFieldNumber = 1,
  };
  // repeated .Frame frames = 1;
  int frames_size() const;
  private:
  int _internal_frames_size() const;
  public:
  void clear_frames();
  ::Frame* mutable_frames(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Frame >*
      mutable_frames();
  private:
  const ::Frame& _internal_frames(int index) const;
  ::Frame* _internal_add_frames();
  public:
  const ::Frame& frames(int index) const;
  ::Frame* add_frames();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Frame >&
      frames() const;

  // @@protoc_insertion_point(class_scope:Backtrace)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Frame > frames_;
  friend struct ::TableStruct_rdb_5fprotocol_2fql2_2eproto;
};
// -------------------------------------------------------------------

class Response :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Response) */ {
 public:
  Response();
  virtual ~Response();

  Response(const Response& from);
  Response(Response&& from) noexcept
    : Response() {
    *this = ::std::move(from);
  }

  inline Response& operator=(const Response& from) {
    CopyFrom(from);
    return *this;
  }
  inline Response& operator=(Response&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Response& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Response* internal_default_instance() {
    return reinterpret_cast<const Response*>(
               &_Response_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(Response& a, Response& b) {
    a.Swap(&b);
  }
  inline void Swap(Response* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Response* New() const final {
    return CreateMaybeMessage<Response>(nullptr);
  }

  Response* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Response>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Response& from);
  void MergeFrom(const Response& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Response* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Response";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_rdb_5fprotocol_2fql2_2eproto);
    return ::descriptor_table_rdb_5fprotocol_2fql2_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef Response_ResponseType ResponseType;
  static constexpr ResponseType SUCCESS_ATOM =
    Response_ResponseType_SUCCESS_ATOM;
  static constexpr ResponseType SUCCESS_SEQUENCE =
    Response_ResponseType_SUCCESS_SEQUENCE;
  static constexpr ResponseType SUCCESS_PARTIAL =
    Response_ResponseType_SUCCESS_PARTIAL;
  static constexpr ResponseType WAIT_COMPLETE =
    Response_ResponseType_WAIT_COMPLETE;
  static constexpr ResponseType SERVER_INFO =
    Response_ResponseType_SERVER_INFO;
  static constexpr ResponseType CLIENT_ERROR =
    Response_ResponseType_CLIENT_ERROR;
  static constexpr ResponseType COMPILE_ERROR =
    Response_ResponseType_COMPILE_ERROR;
  static constexpr ResponseType RUNTIME_ERROR =
    Response_ResponseType_RUNTIME_ERROR;
  static inline bool ResponseType_IsValid(int value) {
    return Response_ResponseType_IsValid(value);
  }
  static constexpr ResponseType ResponseType_MIN =
    Response_ResponseType_ResponseType_MIN;
  static constexpr ResponseType ResponseType_MAX =
    Response_ResponseType_ResponseType_MAX;
  static constexpr int ResponseType_ARRAYSIZE =
    Response_ResponseType_ResponseType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  ResponseType_descriptor() {
    return Response_ResponseType_descriptor();
  }
  template<typename T>
  static inline const std::string& ResponseType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, ResponseType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function ResponseType_Name.");
    return Response_ResponseType_Name(enum_t_value);
  }
  static inline bool ResponseType_Parse(const std::string& name,
      ResponseType* value) {
    return Response_ResponseType_Parse(name, value);
  }

  typedef Response_ErrorType ErrorType;
  static constexpr ErrorType INTERNAL =
    Response_ErrorType_INTERNAL;
  static constexpr ErrorType RESOURCE_LIMIT =
    Response_ErrorType_RESOURCE_LIMIT;
  static constexpr ErrorType QUERY_LOGIC =
    Response_ErrorType_QUERY_LOGIC;
  static constexpr ErrorType NON_EXISTENCE =
    Response_ErrorType_NON_EXISTENCE;
  static constexpr ErrorType OP_FAILED =
    Response_ErrorType_OP_FAILED;
  static constexpr ErrorType OP_INDETERMINATE =
    Response_ErrorType_OP_INDETERMINATE;
  static constexpr ErrorType USER =
    Response_ErrorType_USER;
  static constexpr ErrorType PERMISSION_ERROR =
    Response_ErrorType_PERMISSION_ERROR;
  static inline bool ErrorType_IsValid(int value) {
    return Response_ErrorType_IsValid(value);
  }
  static constexpr ErrorType ErrorType_MIN =
    Response_ErrorType_ErrorType_MIN;
  static constexpr ErrorType ErrorType_MAX =
    Response_ErrorType_ErrorType_MAX;
  static constexpr int ErrorType_ARRAYSIZE =
    Response_ErrorType_ErrorType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  ErrorType_descriptor() {
    return Response_ErrorType_descriptor();
  }
  template<typename T>
  static inline const std::string& ErrorType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, ErrorType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function ErrorType_Name.");
    return Response_ErrorType_Name(enum_t_value);
  }
  static inline bool ErrorType_Parse(const std::string& name,
      ErrorType* value) {
    return Response_ErrorType_Parse(name, value);
  }

  typedef Response_ResponseNote ResponseNote;
  static constexpr ResponseNote SEQUENCE_FEED =
    Response_ResponseNote_SEQUENCE_FEED;
  static constexpr ResponseNote ATOM_FEED =
    Response_ResponseNote_ATOM_FEED;
  static constexpr ResponseNote ORDER_BY_LIMIT_FEED =
    Response_ResponseNote_ORDER_BY_LIMIT_FEED;
  static constexpr ResponseNote UNIONED_FEED =
    Response_ResponseNote_UNIONED_FEED;
  static constexpr ResponseNote INCLUDES_STATES =
    Response_ResponseNote_INCLUDES_STATES;
  static inline bool ResponseNote_IsValid(int value) {
    return Response_ResponseNote_IsValid(value);
  }
  static constexpr ResponseNote ResponseNote_MIN =
    Response_ResponseNote_ResponseNote_MIN;
  static constexpr ResponseNote ResponseNote_MAX =
    Response_ResponseNote_ResponseNote_MAX;
  static constexpr int ResponseNote_ARRAYSIZE =
    Response_ResponseNote_ResponseNote_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  ResponseNote_descriptor() {
    return Response_ResponseNote_descriptor();
  }
  template<typename T>
  static inline const std::string& ResponseNote_Name(T enum_t_value) {
    static_assert(::std::is_same<T, ResponseNote>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function ResponseNote_Name.");
    return Response_ResponseNote_Name(enum_t_value);
  }
  static inline bool ResponseNote_Parse(const std::string& name,
      ResponseNote* value) {
    return Response_ResponseNote_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kResponseFieldNumber = 3,
    kNotesFieldNumber = 6,
    kBacktraceFieldNumber = 4,
    kProfileFieldNumber = 5,
    kTokenFieldNumber = 2,
    kTypeFieldNumber = 1,
    kErrorTypeFieldNumber = 7,
  };
  // repeated .Datum response = 3;
  int response_size() const;
  private:
  int _internal_response_size() const;
  public:
  void clear_response();
  ::Datum* mutable_response(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Datum >*
      mutable_response();
  private:
  const ::Datum& _internal_response(int index) const;
  ::Datum* _internal_add_response();
  public:
  const ::Datum& response(int index) const;
  ::Datum* add_response();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Datum >&
      response() const;

  // repeated .Response.ResponseNote notes = 6;
  int notes_size() const;
  private:
  int _internal_notes_size() const;
  public:
  void clear_notes();
  private:
  ::Response_ResponseNote _internal_notes(int index) const;
  void _internal_add_notes(::Response_ResponseNote value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* _internal_mutable_notes();
  public:
  ::Response_ResponseNote notes(int index) const;
  void set_notes(int index, ::Response_ResponseNote value);
  void add_notes(::Response_ResponseNote value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>& notes() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* mutable_notes();

  // optional .Backtrace backtrace = 4;
  bool has_backtrace() const;
  private:
  bool _internal_has_backtrace() const;
  public:
  void clear_backtrace();
  const ::Backtrace& backtrace() const;
  ::Backtrace* release_backtrace();
  ::Backtrace* mutable_backtrace();
  void set_allocated_backtrace(::Backtrace* backtrace);
  private:
  const ::Backtrace& _internal_backtrace() const;
  ::Backtrace* _internal_mutable_backtrace();
  public:

  // optional .Datum profile = 5;
  bool has_profile() const;
  private:
  bool _internal_has_profile() const;
  public:
  void clear_profile();
  const ::Datum& profile() const;
  ::Datum* release_profile();
  ::Datum* mutable_profile();
  void set_allocated_profile(::Datum* profile);
  private:
  const ::Datum& _internal_profile() const;
  ::Datum* _internal_mutable_profile();
  public:

  // optional int64 token = 2;
  bool has_token() const;
  private:
  bool _internal_has_token() const;
  public:
  void clear_token();
  ::PROTOBUF_NAMESPACE_ID::int64 token() const;
  void set_token(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_token() const;
  void _internal_set_token(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // optional .Response.ResponseType type = 1;
  bool has_type() const;
  private:
  bool _internal_has_type() const;
  public:
  void clear_type();
  ::Response_ResponseType type() const;
  void set_type(::Response_ResponseType value);
  private:
  ::Response_ResponseType _internal_type() const;
  void _internal_set_type(::Response_ResponseType value);
  public:

  // optional .Response.ErrorType error_type = 7;
  bool has_error_type() const;
  private:
  bool _internal_has_error_type() const;
  public:
  void clear_error_type();
  ::Response_ErrorType error_type() const;
  void set_error_type(::Response_ErrorType value);
  private:
  ::Response_ErrorType _internal_error_type() const;
  void _internal_set_error_type(::Response_ErrorType value);
  public:

  // @@protoc_insertion_point(class_scope:Response)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Datum > response_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int> notes_;
  ::Backtrace* backtrace_;
  ::Datum* profile_;
  ::PROTOBUF_NAMESPACE_ID::int64 token_;
  int type_;
  int error_type_;
  friend struct ::TableStruct_rdb_5fprotocol_2fql2_2eproto;
};
// -------------------------------------------------------------------

class Datum_AssocPair :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Datum.AssocPair) */ {
 public:
  Datum_AssocPair();
  virtual ~Datum_AssocPair();

  Datum_AssocPair(const Datum_AssocPair& from);
  Datum_AssocPair(Datum_AssocPair&& from) noexcept
    : Datum_AssocPair() {
    *this = ::std::move(from);
  }

  inline Datum_AssocPair& operator=(const Datum_AssocPair& from) {
    CopyFrom(from);
    return *this;
  }
  inline Datum_AssocPair& operator=(Datum_AssocPair&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Datum_AssocPair& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Datum_AssocPair* internal_default_instance() {
    return reinterpret_cast<const Datum_AssocPair*>(
               &_Datum_AssocPair_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(Datum_AssocPair& a, Datum_AssocPair& b) {
    a.Swap(&b);
  }
  inline void Swap(Datum_AssocPair* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Datum_AssocPair* New() const final {
    return CreateMaybeMessage<Datum_AssocPair>(nullptr);
  }

  Datum_AssocPair* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Datum_AssocPair>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Datum_AssocPair& from);
  void MergeFrom(const Datum_AssocPair& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Datum_AssocPair* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Datum.AssocPair";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_rdb_5fprotocol_2fql2_2eproto);
    return ::descriptor_table_rdb_5fprotocol_2fql2_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kKeyFieldNumber = 1,
    kValFieldNumber = 2,
  };
  // optional string key = 1;
  bool has_key() const;
  private:
  bool _internal_has_key() const;
  public:
  void clear_key();
  const std::string& key() const;
  void set_key(const std::string& value);
  void set_key(std::string&& value);
  void set_key(const char* value);
  void set_key(const char* value, size_t size);
  std::string* mutable_key();
  std::string* release_key();
  void set_allocated_key(std::string* key);
  private:
  const std::string& _internal_key() const;
  void _internal_set_key(const std::string& value);
  std::string* _internal_mutable_key();
  public:

  // optional .Datum val = 2;
  bool has_val() const;
  private:
  bool _internal_has_val() const;
  public:
  void clear_val();
  const ::Datum& val() const;
  ::Datum* release_val();
  ::Datum* mutable_val();
  void set_allocated_val(::Datum* val);
  private:
  const ::Datum& _internal_val() const;
  ::Datum* _internal_mutable_val();
  public:

  // @@protoc_insertion_point(class_scope:Datum.AssocPair)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr key_;
  ::Datum* val_;
  friend struct ::TableStruct_rdb_5fprotocol_2fql2_2eproto;
};
// -------------------------------------------------------------------

class Datum :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Datum) */ {
 public:
  Datum();
  virtual ~Datum();

  Datum(const Datum& from);
  Datum(Datum&& from) noexcept
    : Datum() {
    *this = ::std::move(from);
  }

  inline Datum& operator=(const Datum& from) {
    CopyFrom(from);
    return *this;
  }
  inline Datum& operator=(Datum&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Datum& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Datum* internal_default_instance() {
    return reinterpret_cast<const Datum*>(
               &_Datum_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(Datum& a, Datum& b) {
    a.Swap(&b);
  }
  inline void Swap(Datum* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Datum* New() const final {
    return CreateMaybeMessage<Datum>(nullptr);
  }

  Datum* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Datum>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Datum& from);
  void MergeFrom(const Datum& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Datum* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Datum";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_rdb_5fprotocol_2fql2_2eproto);
    return ::descriptor_table_rdb_5fprotocol_2fql2_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef Datum_AssocPair AssocPair;

  typedef Datum_DatumType DatumType;
  static constexpr DatumType R_NULL =
    Datum_DatumType_R_NULL;
  static constexpr DatumType R_BOOL =
    Datum_DatumType_R_BOOL;
  static constexpr DatumType R_NUM =
    Datum_DatumType_R_NUM;
  static constexpr DatumType R_STR =
    Datum_DatumType_R_STR;
  static constexpr DatumType R_ARRAY =
    Datum_DatumType_R_ARRAY;
  static constexpr DatumType R_OBJECT =
    Datum_DatumType_R_OBJECT;
  static constexpr DatumType R_JSON =
    Datum_DatumType_R_JSON;
  static inline bool DatumType_IsValid(int value) {
    return Datum_DatumType_IsValid(value);
  }
  static constexpr DatumType DatumType_MIN =
    Datum_DatumType_DatumType_MIN;
  static constexpr DatumType DatumType_MAX =
    Datum_DatumType_DatumType_MAX;
  static constexpr int DatumType_ARRAYSIZE =
    Datum_DatumType_DatumType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  DatumType_descriptor() {
    return Datum_DatumType_descriptor();
  }
  template<typename T>
  static inline const std::string& DatumType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, DatumType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function DatumType_Name.");
    return Datum_DatumType_Name(enum_t_value);
  }
  static inline bool DatumType_Parse(const std::string& name,
      DatumType* value) {
    return Datum_DatumType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kRArrayFieldNumber = 5,
    kRObjectFieldNumber = 6,
    kRStrFieldNumber = 4,
    kRNumFieldNumber = 3,
    kRBoolFieldNumber = 2,
    kTypeFieldNumber = 1,
  };
  // repeated .Datum r_array = 5;
  int r_array_size() const;
  private:
  int _internal_r_array_size() const;
  public:
  void clear_r_array();
  ::Datum* mutable_r_array(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Datum >*
      mutable_r_array();
  private:
  const ::Datum& _internal_r_array(int index) const;
  ::Datum* _internal_add_r_array();
  public:
  const ::Datum& r_array(int index) const;
  ::Datum* add_r_array();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Datum >&
      r_array() const;

  // repeated .Datum.AssocPair r_object = 6;
  int r_object_size() const;
  private:
  int _internal_r_object_size() const;
  public:
  void clear_r_object();
  ::Datum_AssocPair* mutable_r_object(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Datum_AssocPair >*
      mutable_r_object();
  private:
  const ::Datum_AssocPair& _internal_r_object(int index) const;
  ::Datum_AssocPair* _internal_add_r_object();
  public:
  const ::Datum_AssocPair& r_object(int index) const;
  ::Datum_AssocPair* add_r_object();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Datum_AssocPair >&
      r_object() const;

  // optional string r_str = 4;
  bool has_r_str() const;
  private:
  bool _internal_has_r_str() const;
  public:
  void clear_r_str();
  const std::string& r_str() const;
  void set_r_str(const std::string& value);
  void set_r_str(std::string&& value);
  void set_r_str(const char* value);
  void set_r_str(const char* value, size_t size);
  std::string* mutable_r_str();
  std::string* release_r_str();
  void set_allocated_r_str(std::string* r_str);
  private:
  const std::string& _internal_r_str() const;
  void _internal_set_r_str(const std::string& value);
  std::string* _internal_mutable_r_str();
  public:

  // optional double r_num = 3;
  bool has_r_num() const;
  private:
  bool _internal_has_r_num() const;
  public:
  void clear_r_num();
  double r_num() const;
  void set_r_num(double value);
  private:
  double _internal_r_num() const;
  void _internal_set_r_num(double value);
  public:

  // optional bool r_bool = 2;
  bool has_r_bool() const;
  private:
  bool _internal_has_r_bool() const;
  public:
  void clear_r_bool();
  bool r_bool() const;
  void set_r_bool(bool value);
  private:
  bool _internal_r_bool() const;
  void _internal_set_r_bool(bool value);
  public:

  // optional .Datum.DatumType type = 1;
  bool has_type() const;
  private:
  bool _internal_has_type() const;
  public:
  void clear_type();
  ::Datum_DatumType type() const;
  void set_type(::Datum_DatumType value);
  private:
  ::Datum_DatumType _internal_type() const;
  void _internal_set_type(::Datum_DatumType value);
  public:

  // @@protoc_insertion_point(class_scope:Datum)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Datum > r_array_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Datum_AssocPair > r_object_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr r_str_;
  double r_num_;
  bool r_bool_;
  int type_;
  friend struct ::TableStruct_rdb_5fprotocol_2fql2_2eproto;
};
// -------------------------------------------------------------------

class Term_AssocPair :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Term.AssocPair) */ {
 public:
  Term_AssocPair();
  virtual ~Term_AssocPair();

  Term_AssocPair(const Term_AssocPair& from);
  Term_AssocPair(Term_AssocPair&& from) noexcept
    : Term_AssocPair() {
    *this = ::std::move(from);
  }

  inline Term_AssocPair& operator=(const Term_AssocPair& from) {
    CopyFrom(from);
    return *this;
  }
  inline Term_AssocPair& operator=(Term_AssocPair&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Term_AssocPair& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Term_AssocPair* internal_default_instance() {
    return reinterpret_cast<const Term_AssocPair*>(
               &_Term_AssocPair_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(Term_AssocPair& a, Term_AssocPair& b) {
    a.Swap(&b);
  }
  inline void Swap(Term_AssocPair* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Term_AssocPair* New() const final {
    return CreateMaybeMessage<Term_AssocPair>(nullptr);
  }

  Term_AssocPair* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Term_AssocPair>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Term_AssocPair& from);
  void MergeFrom(const Term_AssocPair& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Term_AssocPair* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Term.AssocPair";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_rdb_5fprotocol_2fql2_2eproto);
    return ::descriptor_table_rdb_5fprotocol_2fql2_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kKeyFieldNumber = 1,
    kValFieldNumber = 2,
  };
  // optional string key = 1;
  bool has_key() const;
  private:
  bool _internal_has_key() const;
  public:
  void clear_key();
  const std::string& key() const;
  void set_key(const std::string& value);
  void set_key(std::string&& value);
  void set_key(const char* value);
  void set_key(const char* value, size_t size);
  std::string* mutable_key();
  std::string* release_key();
  void set_allocated_key(std::string* key);
  private:
  const std::string& _internal_key() const;
  void _internal_set_key(const std::string& value);
  std::string* _internal_mutable_key();
  public:

  // optional .Term val = 2;
  bool has_val() const;
  private:
  bool _internal_has_val() const;
  public:
  void clear_val();
  const ::Term& val() const;
  ::Term* release_val();
  ::Term* mutable_val();
  void set_allocated_val(::Term* val);
  private:
  const ::Term& _internal_val() const;
  ::Term* _internal_mutable_val();
  public:

  // @@protoc_insertion_point(class_scope:Term.AssocPair)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr key_;
  ::Term* val_;
  friend struct ::TableStruct_rdb_5fprotocol_2fql2_2eproto;
};
// -------------------------------------------------------------------

class Term :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Term) */ {
 public:
  Term();
  virtual ~Term();

  Term(const Term& from);
  Term(Term&& from) noexcept
    : Term() {
    *this = ::std::move(from);
  }

  inline Term& operator=(const Term& from) {
    CopyFrom(from);
    return *this;
  }
  inline Term& operator=(Term&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Term& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Term* internal_default_instance() {
    return reinterpret_cast<const Term*>(
               &_Term_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(Term& a, Term& b) {
    a.Swap(&b);
  }
  inline void Swap(Term* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Term* New() const final {
    return CreateMaybeMessage<Term>(nullptr);
  }

  Term* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Term>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Term& from);
  void MergeFrom(const Term& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Term* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Term";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_rdb_5fprotocol_2fql2_2eproto);
    return ::descriptor_table_rdb_5fprotocol_2fql2_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef Term_AssocPair AssocPair;

  typedef Term_TermType TermType;
  static constexpr TermType DATUM =
    Term_TermType_DATUM;
  static constexpr TermType MAKE_ARRAY =
    Term_TermType_MAKE_ARRAY;
  static constexpr TermType MAKE_OBJ =
    Term_TermType_MAKE_OBJ;
  static constexpr TermType VAR =
    Term_TermType_VAR;
  static constexpr TermType JAVASCRIPT =
    Term_TermType_JAVASCRIPT;
  static constexpr TermType UUID =
    Term_TermType_UUID;
  static constexpr TermType HTTP =
    Term_TermType_HTTP;
  static constexpr TermType ERROR =
    Term_TermType_ERROR;
  static constexpr TermType IMPLICIT_VAR =
    Term_TermType_IMPLICIT_VAR;
  static constexpr TermType DB =
    Term_TermType_DB;
  static constexpr TermType TABLE =
    Term_TermType_TABLE;
  static constexpr TermType GET =
    Term_TermType_GET;
  static constexpr TermType GET_ALL =
    Term_TermType_GET_ALL;
  static constexpr TermType EQ =
    Term_TermType_EQ;
  static constexpr TermType NE =
    Term_TermType_NE;
  static constexpr TermType LT =
    Term_TermType_LT;
  static constexpr TermType LE =
    Term_TermType_LE;
  static constexpr TermType GT =
    Term_TermType_GT;
  static constexpr TermType GE =
    Term_TermType_GE;
  static constexpr TermType NOT =
    Term_TermType_NOT;
  static constexpr TermType ADD =
    Term_TermType_ADD;
  static constexpr TermType SUB =
    Term_TermType_SUB;
  static constexpr TermType MUL =
    Term_TermType_MUL;
  static constexpr TermType DIV =
    Term_TermType_DIV;
  static constexpr TermType MOD =
    Term_TermType_MOD;
  static constexpr TermType FLOOR =
    Term_TermType_FLOOR;
  static constexpr TermType CEIL =
    Term_TermType_CEIL;
  static constexpr TermType ROUND =
    Term_TermType_ROUND;
  static constexpr TermType APPEND =
    Term_TermType_APPEND;
  static constexpr TermType PREPEND =
    Term_TermType_PREPEND;
  static constexpr TermType DIFFERENCE =
    Term_TermType_DIFFERENCE;
  static constexpr TermType SET_INSERT =
    Term_TermType_SET_INSERT;
  static constexpr TermType SET_INTERSECTION =
    Term_TermType_SET_INTERSECTION;
  static constexpr TermType SET_UNION =
    Term_TermType_SET_UNION;
  static constexpr TermType SET_DIFFERENCE =
    Term_TermType_SET_DIFFERENCE;
  static constexpr TermType SLICE =
    Term_TermType_SLICE;
  static constexpr TermType SKIP =
    Term_TermType_SKIP;
  static constexpr TermType LIMIT =
    Term_TermType_LIMIT;
  static constexpr TermType OFFSETS_OF =
    Term_TermType_OFFSETS_OF;
  static constexpr TermType CONTAINS =
    Term_TermType_CONTAINS;
  static constexpr TermType GET_FIELD =
    Term_TermType_GET_FIELD;
  static constexpr TermType KEYS =
    Term_TermType_KEYS;
  static constexpr TermType VALUES =
    Term_TermType_VALUES;
  static constexpr TermType OBJECT =
    Term_TermType_OBJECT;
  static constexpr TermType HAS_FIELDS =
    Term_TermType_HAS_FIELDS;
  static constexpr TermType WITH_FIELDS =
    Term_TermType_WITH_FIELDS;
  static constexpr TermType PLUCK =
    Term_TermType_PLUCK;
  static constexpr TermType WITHOUT =
    Term_TermType_WITHOUT;
  static constexpr TermType MERGE =
    Term_TermType_MERGE;
  static constexpr TermType BETWEEN_DEPRECATED =
    Term_TermType_BETWEEN_DEPRECATED;
  static constexpr TermType BETWEEN =
    Term_TermType_BETWEEN;
  static constexpr TermType REDUCE =
    Term_TermType_REDUCE;
  static constexpr TermType MAP =
    Term_TermType_MAP;
  static constexpr TermType FOLD =
    Term_TermType_FOLD;
  static constexpr TermType FILTER =
    Term_TermType_FILTER;
  static constexpr TermType CONCAT_MAP =
    Term_TermType_CONCAT_MAP;
  static constexpr TermType ORDER_BY =
    Term_TermType_ORDER_BY;
  static constexpr TermType DISTINCT =
    Term_TermType_DISTINCT;
  static constexpr TermType COUNT =
    Term_TermType_COUNT;
  static constexpr TermType IS_EMPTY =
    Term_TermType_IS_EMPTY;
  static constexpr TermType UNION =
    Term_TermType_UNION;
  static constexpr TermType NTH =
    Term_TermType_NTH;
  static constexpr TermType BRACKET =
    Term_TermType_BRACKET;
  static constexpr TermType INNER_JOIN =
    Term_TermType_INNER_JOIN;
  static constexpr TermType OUTER_JOIN =
    Term_TermType_OUTER_JOIN;
  static constexpr TermType EQ_JOIN =
    Term_TermType_EQ_JOIN;
  static constexpr TermType ZIP =
    Term_TermType_ZIP;
  static constexpr TermType RANGE =
    Term_TermType_RANGE;
  static constexpr TermType INSERT_AT =
    Term_TermType_INSERT_AT;
  static constexpr TermType DELETE_AT =
    Term_TermType_DELETE_AT;
  static constexpr TermType CHANGE_AT =
    Term_TermType_CHANGE_AT;
  static constexpr TermType SPLICE_AT =
    Term_TermType_SPLICE_AT;
  static constexpr TermType COERCE_TO =
    Term_TermType_COERCE_TO;
  static constexpr TermType TYPE_OF =
    Term_TermType_TYPE_OF;
  static constexpr TermType UPDATE =
    Term_TermType_UPDATE;
  static constexpr TermType DELETE =
    Term_TermType_DELETE;
  static constexpr TermType REPLACE =
    Term_TermType_REPLACE;
  static constexpr TermType INSERT =
    Term_TermType_INSERT;
  static constexpr TermType DB_CREATE =
    Term_TermType_DB_CREATE;
  static constexpr TermType DB_DROP =
    Term_TermType_DB_DROP;
  static constexpr TermType DB_LIST =
    Term_TermType_DB_LIST;
  static constexpr TermType TABLE_CREATE =
    Term_TermType_TABLE_CREATE;
  static constexpr TermType TABLE_DROP =
    Term_TermType_TABLE_DROP;
  static constexpr TermType TABLE_LIST =
    Term_TermType_TABLE_LIST;
  static constexpr TermType CONFIG =
    Term_TermType_CONFIG;
  static constexpr TermType STATUS =
    Term_TermType_STATUS;
  static constexpr TermType WAIT =
    Term_TermType_WAIT;
  static constexpr TermType RECONFIGURE =
    Term_TermType_RECONFIGURE;
  static constexpr TermType REBALANCE =
    Term_TermType_REBALANCE;
  static constexpr TermType SYNC =
    Term_TermType_SYNC;
  static constexpr TermType GRANT =
    Term_TermType_GRANT;
  static constexpr TermType INDEX_CREATE =
    Term_TermType_INDEX_CREATE;
  static constexpr TermType INDEX_DROP =
    Term_TermType_INDEX_DROP;
  static constexpr TermType INDEX_LIST =
    Term_TermType_INDEX_LIST;
  static constexpr TermType INDEX_STATUS =
    Term_TermType_INDEX_STATUS;
  static constexpr TermType INDEX_WAIT =
    Term_TermType_INDEX_WAIT;
  static constexpr TermType INDEX_RENAME =
    Term_TermType_INDEX_RENAME;
  static constexpr TermType SET_WRITE_HOOK =
    Term_TermType_SET_WRITE_HOOK;
  static constexpr TermType GET_WRITE_HOOK =
    Term_TermType_GET_WRITE_HOOK;
  static constexpr TermType FUNCALL =
    Term_TermType_FUNCALL;
  static constexpr TermType BRANCH =
    Term_TermType_BRANCH;
  static constexpr TermType OR =
    Term_TermType_OR;
  static constexpr TermType AND =
    Term_TermType_AND;
  static constexpr TermType FOR_EACH =
    Term_TermType_FOR_EACH;
  static constexpr TermType FUNC =
    Term_TermType_FUNC;
  static constexpr TermType ASC =
    Term_TermType_ASC;
  static constexpr TermType DESC =
    Term_TermType_DESC;
  static constexpr TermType INFO =
    Term_TermType_INFO;
  static constexpr TermType MATCH =
    Term_TermType_MATCH;
  static constexpr TermType UPCASE =
    Term_TermType_UPCASE;
  static constexpr TermType DOWNCASE =
    Term_TermType_DOWNCASE;
  static constexpr TermType SAMPLE =
    Term_TermType_SAMPLE;
  static constexpr TermType DEFAULT =
    Term_TermType_DEFAULT;
  static constexpr TermType JSON =
    Term_TermType_JSON;
  static constexpr TermType ISO8601 =
    Term_TermType_ISO8601;
  static constexpr TermType TO_ISO8601 =
    Term_TermType_TO_ISO8601;
  static constexpr TermType EPOCH_TIME =
    Term_TermType_EPOCH_TIME;
  static constexpr TermType TO_EPOCH_TIME =
    Term_TermType_TO_EPOCH_TIME;
  static constexpr TermType NOW =
    Term_TermType_NOW;
  static constexpr TermType IN_TIMEZONE =
    Term_TermType_IN_TIMEZONE;
  static constexpr TermType DURING =
    Term_TermType_DURING;
  static constexpr TermType DATE =
    Term_TermType_DATE;
  static constexpr TermType TIME_OF_DAY =
    Term_TermType_TIME_OF_DAY;
  static constexpr TermType TIMEZONE =
    Term_TermType_TIMEZONE;
  static constexpr TermType YEAR =
    Term_TermType_YEAR;
  static constexpr TermType MONTH =
    Term_TermType_MONTH;
  static constexpr TermType DAY =
    Term_TermType_DAY;
  static constexpr TermType DAY_OF_WEEK =
    Term_TermType_DAY_OF_WEEK;
  static constexpr TermType DAY_OF_YEAR =
    Term_TermType_DAY_OF_YEAR;
  static constexpr TermType HOURS =
    Term_TermType_HOURS;
  static constexpr TermType MINUTES =
    Term_TermType_MINUTES;
  static constexpr TermType SECONDS =
    Term_TermType_SECONDS;
  static constexpr TermType TIME =
    Term_TermType_TIME;
  static constexpr TermType MONDAY =
    Term_TermType_MONDAY;
  static constexpr TermType TUESDAY =
    Term_TermType_TUESDAY;
  static constexpr TermType WEDNESDAY =
    Term_TermType_WEDNESDAY;
  static constexpr TermType THURSDAY =
    Term_TermType_THURSDAY;
  static constexpr TermType FRIDAY =
    Term_TermType_FRIDAY;
  static constexpr TermType SATURDAY =
    Term_TermType_SATURDAY;
  static constexpr TermType SUNDAY =
    Term_TermType_SUNDAY;
  static constexpr TermType JANUARY =
    Term_TermType_JANUARY;
  static constexpr TermType FEBRUARY =
    Term_TermType_FEBRUARY;
  static constexpr TermType MARCH =
    Term_TermType_MARCH;
  static constexpr TermType APRIL =
    Term_TermType_APRIL;
  static constexpr TermType MAY =
    Term_TermType_MAY;
  static constexpr TermType JUNE =
    Term_TermType_JUNE;
  static constexpr TermType JULY =
    Term_TermType_JULY;
  static constexpr TermType AUGUST =
    Term_TermType_AUGUST;
  static constexpr TermType SEPTEMBER =
    Term_TermType_SEPTEMBER;
  static constexpr TermType OCTOBER =
    Term_TermType_OCTOBER;
  static constexpr TermType NOVEMBER =
    Term_TermType_NOVEMBER;
  static constexpr TermType DECEMBER =
    Term_TermType_DECEMBER;
  static constexpr TermType LITERAL =
    Term_TermType_LITERAL;
  static constexpr TermType GROUP =
    Term_TermType_GROUP;
  static constexpr TermType SUM =
    Term_TermType_SUM;
  static constexpr TermType AVG =
    Term_TermType_AVG;
  static constexpr TermType MIN =
    Term_TermType_MIN;
  static constexpr TermType MAX =
    Term_TermType_MAX;
  static constexpr TermType SPLIT =
    Term_TermType_SPLIT;
  static constexpr TermType UNGROUP =
    Term_TermType_UNGROUP;
  static constexpr TermType RANDOM =
    Term_TermType_RANDOM;
  static constexpr TermType CHANGES =
    Term_TermType_CHANGES;
  static constexpr TermType ARGS =
    Term_TermType_ARGS;
  static constexpr TermType BINARY =
    Term_TermType_BINARY;
  static constexpr TermType GEOJSON =
    Term_TermType_GEOJSON;
  static constexpr TermType TO_GEOJSON =
    Term_TermType_TO_GEOJSON;
  static constexpr TermType POINT =
    Term_TermType_POINT;
  static constexpr TermType LINE =
    Term_TermType_LINE;
  static constexpr TermType POLYGON =
    Term_TermType_POLYGON;
  static constexpr TermType DISTANCE =
    Term_TermType_DISTANCE;
  static constexpr TermType INTERSECTS =
    Term_TermType_INTERSECTS;
  static constexpr TermType INCLUDES =
    Term_TermType_INCLUDES;
  static constexpr TermType CIRCLE =
    Term_TermType_CIRCLE;
  static constexpr TermType GET_INTERSECTING =
    Term_TermType_GET_INTERSECTING;
  static constexpr TermType FILL =
    Term_TermType_FILL;
  static constexpr TermType GET_NEAREST =
    Term_TermType_GET_NEAREST;
  static constexpr TermType POLYGON_SUB =
    Term_TermType_POLYGON_SUB;
  static constexpr TermType TO_JSON_STRING =
    Term_TermType_TO_JSON_STRING;
  static constexpr TermType MINVAL =
    Term_TermType_MINVAL;
  static constexpr TermType MAXVAL =
    Term_TermType_MAXVAL;
  static constexpr TermType BIT_AND =
    Term_TermType_BIT_AND;
  static constexpr TermType BIT_OR =
    Term_TermType_BIT_OR;
  static constexpr TermType BIT_XOR =
    Term_TermType_BIT_XOR;
  static constexpr TermType BIT_NOT =
    Term_TermType_BIT_NOT;
  static constexpr TermType BIT_SAL =
    Term_TermType_BIT_SAL;
  static constexpr TermType BIT_SAR =
    Term_TermType_BIT_SAR;
  static inline bool TermType_IsValid(int value) {
    return Term_TermType_IsValid(value);
  }
  static constexpr TermType TermType_MIN =
    Term_TermType_TermType_MIN;
  static constexpr TermType TermType_MAX =
    Term_TermType_TermType_MAX;
  static constexpr int TermType_ARRAYSIZE =
    Term_TermType_TermType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  TermType_descriptor() {
    return Term_TermType_descriptor();
  }
  template<typename T>
  static inline const std::string& TermType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, TermType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function TermType_Name.");
    return Term_TermType_Name(enum_t_value);
  }
  static inline bool TermType_Parse(const std::string& name,
      TermType* value) {
    return Term_TermType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kArgsFieldNumber = 3,
    kOptargsFieldNumber = 4,
    kDatumFieldNumber = 2,
    kTypeFieldNumber = 1,
  };
  // repeated .Term args = 3;
  int args_size() const;
  private:
  int _internal_args_size() const;
  public:
  void clear_args();
  ::Term* mutable_args(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Term >*
      mutable_args();
  private:
  const ::Term& _internal_args(int index) const;
  ::Term* _internal_add_args();
  public:
  const ::Term& args(int index) const;
  ::Term* add_args();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Term >&
      args() const;

  // repeated .Term.AssocPair optargs = 4;
  int optargs_size() const;
  private:
  int _internal_optargs_size() const;
  public:
  void clear_optargs();
  ::Term_AssocPair* mutable_optargs(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Term_AssocPair >*
      mutable_optargs();
  private:
  const ::Term_AssocPair& _internal_optargs(int index) const;
  ::Term_AssocPair* _internal_add_optargs();
  public:
  const ::Term_AssocPair& optargs(int index) const;
  ::Term_AssocPair* add_optargs();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Term_AssocPair >&
      optargs() const;

  // optional .Datum datum = 2;
  bool has_datum() const;
  private:
  bool _internal_has_datum() const;
  public:
  void clear_datum();
  const ::Datum& datum() const;
  ::Datum* release_datum();
  ::Datum* mutable_datum();
  void set_allocated_datum(::Datum* datum);
  private:
  const ::Datum& _internal_datum() const;
  ::Datum* _internal_mutable_datum();
  public:

  // optional .Term.TermType type = 1;
  bool has_type() const;
  private:
  bool _internal_has_type() const;
  public:
  void clear_type();
  ::Term_TermType type() const;
  void set_type(::Term_TermType value);
  private:
  ::Term_TermType _internal_type() const;
  void _internal_set_type(::Term_TermType value);
  public:

  // @@protoc_insertion_point(class_scope:Term)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Term > args_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Term_AssocPair > optargs_;
  ::Datum* datum_;
  int type_;
  friend struct ::TableStruct_rdb_5fprotocol_2fql2_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// VersionDummy

// -------------------------------------------------------------------

// Query_AssocPair

// optional string key = 1;
inline bool Query_AssocPair::_internal_has_key() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Query_AssocPair::has_key() const {
  return _internal_has_key();
}
inline void Query_AssocPair::clear_key() {
  key_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& Query_AssocPair::key() const {
  // @@protoc_insertion_point(field_get:Query.AssocPair.key)
  return _internal_key();
}
inline void Query_AssocPair::set_key(const std::string& value) {
  _internal_set_key(value);
  // @@protoc_insertion_point(field_set:Query.AssocPair.key)
}
inline std::string* Query_AssocPair::mutable_key() {
  // @@protoc_insertion_point(field_mutable:Query.AssocPair.key)
  return _internal_mutable_key();
}
inline const std::string& Query_AssocPair::_internal_key() const {
  return key_.GetNoArena();
}
inline void Query_AssocPair::_internal_set_key(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  key_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void Query_AssocPair::set_key(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  key_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Query.AssocPair.key)
}
inline void Query_AssocPair::set_key(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  key_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Query.AssocPair.key)
}
inline void Query_AssocPair::set_key(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  key_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Query.AssocPair.key)
}
inline std::string* Query_AssocPair::_internal_mutable_key() {
  _has_bits_[0] |= 0x00000001u;
  return key_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* Query_AssocPair::release_key() {
  // @@protoc_insertion_point(field_release:Query.AssocPair.key)
  if (!_internal_has_key()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return key_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void Query_AssocPair::set_allocated_key(std::string* key) {
  if (key != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  key_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), key);
  // @@protoc_insertion_point(field_set_allocated:Query.AssocPair.key)
}

// optional .Term val = 2;
inline bool Query_AssocPair::_internal_has_val() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || val_ != nullptr);
  return value;
}
inline bool Query_AssocPair::has_val() const {
  return _internal_has_val();
}
inline void Query_AssocPair::clear_val() {
  if (val_ != nullptr) val_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::Term& Query_AssocPair::_internal_val() const {
  const ::Term* p = val_;
  return p != nullptr ? *p : *reinterpret_cast<const ::Term*>(
      &::_Term_default_instance_);
}
inline const ::Term& Query_AssocPair::val() const {
  // @@protoc_insertion_point(field_get:Query.AssocPair.val)
  return _internal_val();
}
inline ::Term* Query_AssocPair::release_val() {
  // @@protoc_insertion_point(field_release:Query.AssocPair.val)
  _has_bits_[0] &= ~0x00000002u;
  ::Term* temp = val_;
  val_ = nullptr;
  return temp;
}
inline ::Term* Query_AssocPair::_internal_mutable_val() {
  _has_bits_[0] |= 0x00000002u;
  if (val_ == nullptr) {
    auto* p = CreateMaybeMessage<::Term>(GetArenaNoVirtual());
    val_ = p;
  }
  return val_;
}
inline ::Term* Query_AssocPair::mutable_val() {
  // @@protoc_insertion_point(field_mutable:Query.AssocPair.val)
  return _internal_mutable_val();
}
inline void Query_AssocPair::set_allocated_val(::Term* val) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete val_;
  }
  if (val) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      val = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, val, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  val_ = val;
  // @@protoc_insertion_point(field_set_allocated:Query.AssocPair.val)
}

// -------------------------------------------------------------------

// Query

// optional .Query.QueryType type = 1;
inline bool Query::_internal_has_type() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool Query::has_type() const {
  return _internal_has_type();
}
inline void Query::clear_type() {
  type_ = 1;
  _has_bits_[0] &= ~0x00000010u;
}
inline ::Query_QueryType Query::_internal_type() const {
  return static_cast< ::Query_QueryType >(type_);
}
inline ::Query_QueryType Query::type() const {
  // @@protoc_insertion_point(field_get:Query.type)
  return _internal_type();
}
inline void Query::_internal_set_type(::Query_QueryType value) {
  assert(::Query_QueryType_IsValid(value));
  _has_bits_[0] |= 0x00000010u;
  type_ = value;
}
inline void Query::set_type(::Query_QueryType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:Query.type)
}

// optional .Term query = 2;
inline bool Query::_internal_has_query() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || query_ != nullptr);
  return value;
}
inline bool Query::has_query() const {
  return _internal_has_query();
}
inline void Query::clear_query() {
  if (query_ != nullptr) query_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::Term& Query::_internal_query() const {
  const ::Term* p = query_;
  return p != nullptr ? *p : *reinterpret_cast<const ::Term*>(
      &::_Term_default_instance_);
}
inline const ::Term& Query::query() const {
  // @@protoc_insertion_point(field_get:Query.query)
  return _internal_query();
}
inline ::Term* Query::release_query() {
  // @@protoc_insertion_point(field_release:Query.query)
  _has_bits_[0] &= ~0x00000001u;
  ::Term* temp = query_;
  query_ = nullptr;
  return temp;
}
inline ::Term* Query::_internal_mutable_query() {
  _has_bits_[0] |= 0x00000001u;
  if (query_ == nullptr) {
    auto* p = CreateMaybeMessage<::Term>(GetArenaNoVirtual());
    query_ = p;
  }
  return query_;
}
inline ::Term* Query::mutable_query() {
  // @@protoc_insertion_point(field_mutable:Query.query)
  return _internal_mutable_query();
}
inline void Query::set_allocated_query(::Term* query) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete query_;
  }
  if (query) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      query = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, query, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  query_ = query;
  // @@protoc_insertion_point(field_set_allocated:Query.query)
}

// optional int64 token = 3;
inline bool Query::_internal_has_token() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool Query::has_token() const {
  return _internal_has_token();
}
inline void Query::clear_token() {
  token_ = PROTOBUF_LONGLONG(0);
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 Query::_internal_token() const {
  return token_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 Query::token() const {
  // @@protoc_insertion_point(field_get:Query.token)
  return _internal_token();
}
inline void Query::_internal_set_token(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000002u;
  token_ = value;
}
inline void Query::set_token(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_token(value);
  // @@protoc_insertion_point(field_set:Query.token)
}

// optional bool OBSOLETE_noreply = 4 [default = false];
inline bool Query::_internal_has_obsolete_noreply() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool Query::has_obsolete_noreply() const {
  return _internal_has_obsolete_noreply();
}
inline void Query::clear_obsolete_noreply() {
  obsolete_noreply_ = false;
  _has_bits_[0] &= ~0x00000004u;
}
inline bool Query::_internal_obsolete_noreply() const {
  return obsolete_noreply_;
}
inline bool Query::obsolete_noreply() const {
  // @@protoc_insertion_point(field_get:Query.OBSOLETE_noreply)
  return _internal_obsolete_noreply();
}
inline void Query::_internal_set_obsolete_noreply(bool value) {
  _has_bits_[0] |= 0x00000004u;
  obsolete_noreply_ = value;
}
inline void Query::set_obsolete_noreply(bool value) {
  _internal_set_obsolete_noreply(value);
  // @@protoc_insertion_point(field_set:Query.OBSOLETE_noreply)
}

// optional bool accepts_r_json = 5 [default = false];
inline bool Query::_internal_has_accepts_r_json() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool Query::has_accepts_r_json() const {
  return _internal_has_accepts_r_json();
}
inline void Query::clear_accepts_r_json() {
  accepts_r_json_ = false;
  _has_bits_[0] &= ~0x00000008u;
}
inline bool Query::_internal_accepts_r_json() const {
  return accepts_r_json_;
}
inline bool Query::accepts_r_json() const {
  // @@protoc_insertion_point(field_get:Query.accepts_r_json)
  return _internal_accepts_r_json();
}
inline void Query::_internal_set_accepts_r_json(bool value) {
  _has_bits_[0] |= 0x00000008u;
  accepts_r_json_ = value;
}
inline void Query::set_accepts_r_json(bool value) {
  _internal_set_accepts_r_json(value);
  // @@protoc_insertion_point(field_set:Query.accepts_r_json)
}

// repeated .Query.AssocPair global_optargs = 6;
inline int Query::_internal_global_optargs_size() const {
  return global_optargs_.size();
}
inline int Query::global_optargs_size() const {
  return _internal_global_optargs_size();
}
inline void Query::clear_global_optargs() {
  global_optargs_.Clear();
}
inline ::Query_AssocPair* Query::mutable_global_optargs(int index) {
  // @@protoc_insertion_point(field_mutable:Query.global_optargs)
  return global_optargs_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Query_AssocPair >*
Query::mutable_global_optargs() {
  // @@protoc_insertion_point(field_mutable_list:Query.global_optargs)
  return &global_optargs_;
}
inline const ::Query_AssocPair& Query::_internal_global_optargs(int index) const {
  return global_optargs_.Get(index);
}
inline const ::Query_AssocPair& Query::global_optargs(int index) const {
  // @@protoc_insertion_point(field_get:Query.global_optargs)
  return _internal_global_optargs(index);
}
inline ::Query_AssocPair* Query::_internal_add_global_optargs() {
  return global_optargs_.Add();
}
inline ::Query_AssocPair* Query::add_global_optargs() {
  // @@protoc_insertion_point(field_add:Query.global_optargs)
  return _internal_add_global_optargs();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Query_AssocPair >&
Query::global_optargs() const {
  // @@protoc_insertion_point(field_list:Query.global_optargs)
  return global_optargs_;
}

// -------------------------------------------------------------------

// Frame

// optional .Frame.FrameType type = 1;
inline bool Frame::_internal_has_type() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool Frame::has_type() const {
  return _internal_has_type();
}
inline void Frame::clear_type() {
  type_ = 1;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::Frame_FrameType Frame::_internal_type() const {
  return static_cast< ::Frame_FrameType >(type_);
}
inline ::Frame_FrameType Frame::type() const {
  // @@protoc_insertion_point(field_get:Frame.type)
  return _internal_type();
}
inline void Frame::_internal_set_type(::Frame_FrameType value) {
  assert(::Frame_FrameType_IsValid(value));
  _has_bits_[0] |= 0x00000004u;
  type_ = value;
}
inline void Frame::set_type(::Frame_FrameType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:Frame.type)
}

// optional int64 pos = 2;
inline bool Frame::_internal_has_pos() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool Frame::has_pos() const {
  return _internal_has_pos();
}
inline void Frame::clear_pos() {
  pos_ = PROTOBUF_LONGLONG(0);
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 Frame::_internal_pos() const {
  return pos_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 Frame::pos() const {
  // @@protoc_insertion_point(field_get:Frame.pos)
  return _internal_pos();
}
inline void Frame::_internal_set_pos(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000002u;
  pos_ = value;
}
inline void Frame::set_pos(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_pos(value);
  // @@protoc_insertion_point(field_set:Frame.pos)
}

// optional string opt = 3;
inline bool Frame::_internal_has_opt() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Frame::has_opt() const {
  return _internal_has_opt();
}
inline void Frame::clear_opt() {
  opt_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& Frame::opt() const {
  // @@protoc_insertion_point(field_get:Frame.opt)
  return _internal_opt();
}
inline void Frame::set_opt(const std::string& value) {
  _internal_set_opt(value);
  // @@protoc_insertion_point(field_set:Frame.opt)
}
inline std::string* Frame::mutable_opt() {
  // @@protoc_insertion_point(field_mutable:Frame.opt)
  return _internal_mutable_opt();
}
inline const std::string& Frame::_internal_opt() const {
  return opt_.GetNoArena();
}
inline void Frame::_internal_set_opt(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  opt_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void Frame::set_opt(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  opt_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Frame.opt)
}
inline void Frame::set_opt(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  opt_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Frame.opt)
}
inline void Frame::set_opt(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  opt_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Frame.opt)
}
inline std::string* Frame::_internal_mutable_opt() {
  _has_bits_[0] |= 0x00000001u;
  return opt_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* Frame::release_opt() {
  // @@protoc_insertion_point(field_release:Frame.opt)
  if (!_internal_has_opt()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return opt_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void Frame::set_allocated_opt(std::string* opt) {
  if (opt != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  opt_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), opt);
  // @@protoc_insertion_point(field_set_allocated:Frame.opt)
}

// -------------------------------------------------------------------

// Backtrace

// repeated .Frame frames = 1;
inline int Backtrace::_internal_frames_size() const {
  return frames_.size();
}
inline int Backtrace::frames_size() const {
  return _internal_frames_size();
}
inline void Backtrace::clear_frames() {
  frames_.Clear();
}
inline ::Frame* Backtrace::mutable_frames(int index) {
  // @@protoc_insertion_point(field_mutable:Backtrace.frames)
  return frames_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Frame >*
Backtrace::mutable_frames() {
  // @@protoc_insertion_point(field_mutable_list:Backtrace.frames)
  return &frames_;
}
inline const ::Frame& Backtrace::_internal_frames(int index) const {
  return frames_.Get(index);
}
inline const ::Frame& Backtrace::frames(int index) const {
  // @@protoc_insertion_point(field_get:Backtrace.frames)
  return _internal_frames(index);
}
inline ::Frame* Backtrace::_internal_add_frames() {
  return frames_.Add();
}
inline ::Frame* Backtrace::add_frames() {
  // @@protoc_insertion_point(field_add:Backtrace.frames)
  return _internal_add_frames();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Frame >&
Backtrace::frames() const {
  // @@protoc_insertion_point(field_list:Backtrace.frames)
  return frames_;
}

// -------------------------------------------------------------------

// Response

// optional .Response.ResponseType type = 1;
inline bool Response::_internal_has_type() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool Response::has_type() const {
  return _internal_has_type();
}
inline void Response::clear_type() {
  type_ = 1;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::Response_ResponseType Response::_internal_type() const {
  return static_cast< ::Response_ResponseType >(type_);
}
inline ::Response_ResponseType Response::type() const {
  // @@protoc_insertion_point(field_get:Response.type)
  return _internal_type();
}
inline void Response::_internal_set_type(::Response_ResponseType value) {
  assert(::Response_ResponseType_IsValid(value));
  _has_bits_[0] |= 0x00000008u;
  type_ = value;
}
inline void Response::set_type(::Response_ResponseType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:Response.type)
}

// optional .Response.ErrorType error_type = 7;
inline bool Response::_internal_has_error_type() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool Response::has_error_type() const {
  return _internal_has_error_type();
}
inline void Response::clear_error_type() {
  error_type_ = 1000000;
  _has_bits_[0] &= ~0x00000010u;
}
inline ::Response_ErrorType Response::_internal_error_type() const {
  return static_cast< ::Response_ErrorType >(error_type_);
}
inline ::Response_ErrorType Response::error_type() const {
  // @@protoc_insertion_point(field_get:Response.error_type)
  return _internal_error_type();
}
inline void Response::_internal_set_error_type(::Response_ErrorType value) {
  assert(::Response_ErrorType_IsValid(value));
  _has_bits_[0] |= 0x00000010u;
  error_type_ = value;
}
inline void Response::set_error_type(::Response_ErrorType value) {
  _internal_set_error_type(value);
  // @@protoc_insertion_point(field_set:Response.error_type)
}

// repeated .Response.ResponseNote notes = 6;
inline int Response::_internal_notes_size() const {
  return notes_.size();
}
inline int Response::notes_size() const {
  return _internal_notes_size();
}
inline void Response::clear_notes() {
  notes_.Clear();
}
inline ::Response_ResponseNote Response::_internal_notes(int index) const {
  return static_cast< ::Response_ResponseNote >(notes_.Get(index));
}
inline ::Response_ResponseNote Response::notes(int index) const {
  // @@protoc_insertion_point(field_get:Response.notes)
  return _internal_notes(index);
}
inline void Response::set_notes(int index, ::Response_ResponseNote value) {
  assert(::Response_ResponseNote_IsValid(value));
  notes_.Set(index, value);
  // @@protoc_insertion_point(field_set:Response.notes)
}
inline void Response::_internal_add_notes(::Response_ResponseNote value) {
  assert(::Response_ResponseNote_IsValid(value));
  notes_.Add(value);
}
inline void Response::add_notes(::Response_ResponseNote value) {
  // @@protoc_insertion_point(field_add:Response.notes)
  _internal_add_notes(value);
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>&
Response::notes() const {
  // @@protoc_insertion_point(field_list:Response.notes)
  return notes_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>*
Response::_internal_mutable_notes() {
  return &notes_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>*
Response::mutable_notes() {
  // @@protoc_insertion_point(field_mutable_list:Response.notes)
  return _internal_mutable_notes();
}

// optional int64 token = 2;
inline bool Response::_internal_has_token() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool Response::has_token() const {
  return _internal_has_token();
}
inline void Response::clear_token() {
  token_ = PROTOBUF_LONGLONG(0);
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 Response::_internal_token() const {
  return token_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 Response::token() const {
  // @@protoc_insertion_point(field_get:Response.token)
  return _internal_token();
}
inline void Response::_internal_set_token(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000004u;
  token_ = value;
}
inline void Response::set_token(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_token(value);
  // @@protoc_insertion_point(field_set:Response.token)
}

// repeated .Datum response = 3;
inline int Response::_internal_response_size() const {
  return response_.size();
}
inline int Response::response_size() const {
  return _internal_response_size();
}
inline void Response::clear_response() {
  response_.Clear();
}
inline ::Datum* Response::mutable_response(int index) {
  // @@protoc_insertion_point(field_mutable:Response.response)
  return response_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Datum >*
Response::mutable_response() {
  // @@protoc_insertion_point(field_mutable_list:Response.response)
  return &response_;
}
inline const ::Datum& Response::_internal_response(int index) const {
  return response_.Get(index);
}
inline const ::Datum& Response::response(int index) const {
  // @@protoc_insertion_point(field_get:Response.response)
  return _internal_response(index);
}
inline ::Datum* Response::_internal_add_response() {
  return response_.Add();
}
inline ::Datum* Response::add_response() {
  // @@protoc_insertion_point(field_add:Response.response)
  return _internal_add_response();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Datum >&
Response::response() const {
  // @@protoc_insertion_point(field_list:Response.response)
  return response_;
}

// optional .Backtrace backtrace = 4;
inline bool Response::_internal_has_backtrace() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || backtrace_ != nullptr);
  return value;
}
inline bool Response::has_backtrace() const {
  return _internal_has_backtrace();
}
inline void Response::clear_backtrace() {
  if (backtrace_ != nullptr) backtrace_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::Backtrace& Response::_internal_backtrace() const {
  const ::Backtrace* p = backtrace_;
  return p != nullptr ? *p : *reinterpret_cast<const ::Backtrace*>(
      &::_Backtrace_default_instance_);
}
inline const ::Backtrace& Response::backtrace() const {
  // @@protoc_insertion_point(field_get:Response.backtrace)
  return _internal_backtrace();
}
inline ::Backtrace* Response::release_backtrace() {
  // @@protoc_insertion_point(field_release:Response.backtrace)
  _has_bits_[0] &= ~0x00000001u;
  ::Backtrace* temp = backtrace_;
  backtrace_ = nullptr;
  return temp;
}
inline ::Backtrace* Response::_internal_mutable_backtrace() {
  _has_bits_[0] |= 0x00000001u;
  if (backtrace_ == nullptr) {
    auto* p = CreateMaybeMessage<::Backtrace>(GetArenaNoVirtual());
    backtrace_ = p;
  }
  return backtrace_;
}
inline ::Backtrace* Response::mutable_backtrace() {
  // @@protoc_insertion_point(field_mutable:Response.backtrace)
  return _internal_mutable_backtrace();
}
inline void Response::set_allocated_backtrace(::Backtrace* backtrace) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete backtrace_;
  }
  if (backtrace) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      backtrace = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, backtrace, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  backtrace_ = backtrace;
  // @@protoc_insertion_point(field_set_allocated:Response.backtrace)
}

// optional .Datum profile = 5;
inline bool Response::_internal_has_profile() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || profile_ != nullptr);
  return value;
}
inline bool Response::has_profile() const {
  return _internal_has_profile();
}
inline void Response::clear_profile() {
  if (profile_ != nullptr) profile_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::Datum& Response::_internal_profile() const {
  const ::Datum* p = profile_;
  return p != nullptr ? *p : *reinterpret_cast<const ::Datum*>(
      &::_Datum_default_instance_);
}
inline const ::Datum& Response::profile() const {
  // @@protoc_insertion_point(field_get:Response.profile)
  return _internal_profile();
}
inline ::Datum* Response::release_profile() {
  // @@protoc_insertion_point(field_release:Response.profile)
  _has_bits_[0] &= ~0x00000002u;
  ::Datum* temp = profile_;
  profile_ = nullptr;
  return temp;
}
inline ::Datum* Response::_internal_mutable_profile() {
  _has_bits_[0] |= 0x00000002u;
  if (profile_ == nullptr) {
    auto* p = CreateMaybeMessage<::Datum>(GetArenaNoVirtual());
    profile_ = p;
  }
  return profile_;
}
inline ::Datum* Response::mutable_profile() {
  // @@protoc_insertion_point(field_mutable:Response.profile)
  return _internal_mutable_profile();
}
inline void Response::set_allocated_profile(::Datum* profile) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete profile_;
  }
  if (profile) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      profile = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, profile, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  profile_ = profile;
  // @@protoc_insertion_point(field_set_allocated:Response.profile)
}

// -------------------------------------------------------------------

// Datum_AssocPair

// optional string key = 1;
inline bool Datum_AssocPair::_internal_has_key() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Datum_AssocPair::has_key() const {
  return _internal_has_key();
}
inline void Datum_AssocPair::clear_key() {
  key_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& Datum_AssocPair::key() const {
  // @@protoc_insertion_point(field_get:Datum.AssocPair.key)
  return _internal_key();
}
inline void Datum_AssocPair::set_key(const std::string& value) {
  _internal_set_key(value);
  // @@protoc_insertion_point(field_set:Datum.AssocPair.key)
}
inline std::string* Datum_AssocPair::mutable_key() {
  // @@protoc_insertion_point(field_mutable:Datum.AssocPair.key)
  return _internal_mutable_key();
}
inline const std::string& Datum_AssocPair::_internal_key() const {
  return key_.GetNoArena();
}
inline void Datum_AssocPair::_internal_set_key(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  key_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void Datum_AssocPair::set_key(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  key_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Datum.AssocPair.key)
}
inline void Datum_AssocPair::set_key(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  key_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Datum.AssocPair.key)
}
inline void Datum_AssocPair::set_key(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  key_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Datum.AssocPair.key)
}
inline std::string* Datum_AssocPair::_internal_mutable_key() {
  _has_bits_[0] |= 0x00000001u;
  return key_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* Datum_AssocPair::release_key() {
  // @@protoc_insertion_point(field_release:Datum.AssocPair.key)
  if (!_internal_has_key()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return key_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void Datum_AssocPair::set_allocated_key(std::string* key) {
  if (key != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  key_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), key);
  // @@protoc_insertion_point(field_set_allocated:Datum.AssocPair.key)
}

// optional .Datum val = 2;
inline bool Datum_AssocPair::_internal_has_val() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || val_ != nullptr);
  return value;
}
inline bool Datum_AssocPair::has_val() const {
  return _internal_has_val();
}
inline void Datum_AssocPair::clear_val() {
  if (val_ != nullptr) val_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::Datum& Datum_AssocPair::_internal_val() const {
  const ::Datum* p = val_;
  return p != nullptr ? *p : *reinterpret_cast<const ::Datum*>(
      &::_Datum_default_instance_);
}
inline const ::Datum& Datum_AssocPair::val() const {
  // @@protoc_insertion_point(field_get:Datum.AssocPair.val)
  return _internal_val();
}
inline ::Datum* Datum_AssocPair::release_val() {
  // @@protoc_insertion_point(field_release:Datum.AssocPair.val)
  _has_bits_[0] &= ~0x00000002u;
  ::Datum* temp = val_;
  val_ = nullptr;
  return temp;
}
inline ::Datum* Datum_AssocPair::_internal_mutable_val() {
  _has_bits_[0] |= 0x00000002u;
  if (val_ == nullptr) {
    auto* p = CreateMaybeMessage<::Datum>(GetArenaNoVirtual());
    val_ = p;
  }
  return val_;
}
inline ::Datum* Datum_AssocPair::mutable_val() {
  // @@protoc_insertion_point(field_mutable:Datum.AssocPair.val)
  return _internal_mutable_val();
}
inline void Datum_AssocPair::set_allocated_val(::Datum* val) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete val_;
  }
  if (val) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      val = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, val, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  val_ = val;
  // @@protoc_insertion_point(field_set_allocated:Datum.AssocPair.val)
}

// -------------------------------------------------------------------

// Datum

// optional .Datum.DatumType type = 1;
inline bool Datum::_internal_has_type() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool Datum::has_type() const {
  return _internal_has_type();
}
inline void Datum::clear_type() {
  type_ = 1;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::Datum_DatumType Datum::_internal_type() const {
  return static_cast< ::Datum_DatumType >(type_);
}
inline ::Datum_DatumType Datum::type() const {
  // @@protoc_insertion_point(field_get:Datum.type)
  return _internal_type();
}
inline void Datum::_internal_set_type(::Datum_DatumType value) {
  assert(::Datum_DatumType_IsValid(value));
  _has_bits_[0] |= 0x00000008u;
  type_ = value;
}
inline void Datum::set_type(::Datum_DatumType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:Datum.type)
}

// optional bool r_bool = 2;
inline bool Datum::_internal_has_r_bool() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool Datum::has_r_bool() const {
  return _internal_has_r_bool();
}
inline void Datum::clear_r_bool() {
  r_bool_ = false;
  _has_bits_[0] &= ~0x00000004u;
}
inline bool Datum::_internal_r_bool() const {
  return r_bool_;
}
inline bool Datum::r_bool() const {
  // @@protoc_insertion_point(field_get:Datum.r_bool)
  return _internal_r_bool();
}
inline void Datum::_internal_set_r_bool(bool value) {
  _has_bits_[0] |= 0x00000004u;
  r_bool_ = value;
}
inline void Datum::set_r_bool(bool value) {
  _internal_set_r_bool(value);
  // @@protoc_insertion_point(field_set:Datum.r_bool)
}

// optional double r_num = 3;
inline bool Datum::_internal_has_r_num() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool Datum::has_r_num() const {
  return _internal_has_r_num();
}
inline void Datum::clear_r_num() {
  r_num_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline double Datum::_internal_r_num() const {
  return r_num_;
}
inline double Datum::r_num() const {
  // @@protoc_insertion_point(field_get:Datum.r_num)
  return _internal_r_num();
}
inline void Datum::_internal_set_r_num(double value) {
  _has_bits_[0] |= 0x00000002u;
  r_num_ = value;
}
inline void Datum::set_r_num(double value) {
  _internal_set_r_num(value);
  // @@protoc_insertion_point(field_set:Datum.r_num)
}

// optional string r_str = 4;
inline bool Datum::_internal_has_r_str() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Datum::has_r_str() const {
  return _internal_has_r_str();
}
inline void Datum::clear_r_str() {
  r_str_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& Datum::r_str() const {
  // @@protoc_insertion_point(field_get:Datum.r_str)
  return _internal_r_str();
}
inline void Datum::set_r_str(const std::string& value) {
  _internal_set_r_str(value);
  // @@protoc_insertion_point(field_set:Datum.r_str)
}
inline std::string* Datum::mutable_r_str() {
  // @@protoc_insertion_point(field_mutable:Datum.r_str)
  return _internal_mutable_r_str();
}
inline const std::string& Datum::_internal_r_str() const {
  return r_str_.GetNoArena();
}
inline void Datum::_internal_set_r_str(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  r_str_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void Datum::set_r_str(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  r_str_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Datum.r_str)
}
inline void Datum::set_r_str(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  r_str_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Datum.r_str)
}
inline void Datum::set_r_str(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  r_str_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Datum.r_str)
}
inline std::string* Datum::_internal_mutable_r_str() {
  _has_bits_[0] |= 0x00000001u;
  return r_str_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* Datum::release_r_str() {
  // @@protoc_insertion_point(field_release:Datum.r_str)
  if (!_internal_has_r_str()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return r_str_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void Datum::set_allocated_r_str(std::string* r_str) {
  if (r_str != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  r_str_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), r_str);
  // @@protoc_insertion_point(field_set_allocated:Datum.r_str)
}

// repeated .Datum r_array = 5;
inline int Datum::_internal_r_array_size() const {
  return r_array_.size();
}
inline int Datum::r_array_size() const {
  return _internal_r_array_size();
}
inline void Datum::clear_r_array() {
  r_array_.Clear();
}
inline ::Datum* Datum::mutable_r_array(int index) {
  // @@protoc_insertion_point(field_mutable:Datum.r_array)
  return r_array_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Datum >*
Datum::mutable_r_array() {
  // @@protoc_insertion_point(field_mutable_list:Datum.r_array)
  return &r_array_;
}
inline const ::Datum& Datum::_internal_r_array(int index) const {
  return r_array_.Get(index);
}
inline const ::Datum& Datum::r_array(int index) const {
  // @@protoc_insertion_point(field_get:Datum.r_array)
  return _internal_r_array(index);
}
inline ::Datum* Datum::_internal_add_r_array() {
  return r_array_.Add();
}
inline ::Datum* Datum::add_r_array() {
  // @@protoc_insertion_point(field_add:Datum.r_array)
  return _internal_add_r_array();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Datum >&
Datum::r_array() const {
  // @@protoc_insertion_point(field_list:Datum.r_array)
  return r_array_;
}

// repeated .Datum.AssocPair r_object = 6;
inline int Datum::_internal_r_object_size() const {
  return r_object_.size();
}
inline int Datum::r_object_size() const {
  return _internal_r_object_size();
}
inline void Datum::clear_r_object() {
  r_object_.Clear();
}
inline ::Datum_AssocPair* Datum::mutable_r_object(int index) {
  // @@protoc_insertion_point(field_mutable:Datum.r_object)
  return r_object_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Datum_AssocPair >*
Datum::mutable_r_object() {
  // @@protoc_insertion_point(field_mutable_list:Datum.r_object)
  return &r_object_;
}
inline const ::Datum_AssocPair& Datum::_internal_r_object(int index) const {
  return r_object_.Get(index);
}
inline const ::Datum_AssocPair& Datum::r_object(int index) const {
  // @@protoc_insertion_point(field_get:Datum.r_object)
  return _internal_r_object(index);
}
inline ::Datum_AssocPair* Datum::_internal_add_r_object() {
  return r_object_.Add();
}
inline ::Datum_AssocPair* Datum::add_r_object() {
  // @@protoc_insertion_point(field_add:Datum.r_object)
  return _internal_add_r_object();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Datum_AssocPair >&
Datum::r_object() const {
  // @@protoc_insertion_point(field_list:Datum.r_object)
  return r_object_;
}

// -------------------------------------------------------------------

// Term_AssocPair

// optional string key = 1;
inline bool Term_AssocPair::_internal_has_key() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Term_AssocPair::has_key() const {
  return _internal_has_key();
}
inline void Term_AssocPair::clear_key() {
  key_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& Term_AssocPair::key() const {
  // @@protoc_insertion_point(field_get:Term.AssocPair.key)
  return _internal_key();
}
inline void Term_AssocPair::set_key(const std::string& value) {
  _internal_set_key(value);
  // @@protoc_insertion_point(field_set:Term.AssocPair.key)
}
inline std::string* Term_AssocPair::mutable_key() {
  // @@protoc_insertion_point(field_mutable:Term.AssocPair.key)
  return _internal_mutable_key();
}
inline const std::string& Term_AssocPair::_internal_key() const {
  return key_.GetNoArena();
}
inline void Term_AssocPair::_internal_set_key(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  key_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void Term_AssocPair::set_key(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  key_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Term.AssocPair.key)
}
inline void Term_AssocPair::set_key(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  key_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Term.AssocPair.key)
}
inline void Term_AssocPair::set_key(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  key_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Term.AssocPair.key)
}
inline std::string* Term_AssocPair::_internal_mutable_key() {
  _has_bits_[0] |= 0x00000001u;
  return key_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* Term_AssocPair::release_key() {
  // @@protoc_insertion_point(field_release:Term.AssocPair.key)
  if (!_internal_has_key()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return key_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void Term_AssocPair::set_allocated_key(std::string* key) {
  if (key != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  key_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), key);
  // @@protoc_insertion_point(field_set_allocated:Term.AssocPair.key)
}

// optional .Term val = 2;
inline bool Term_AssocPair::_internal_has_val() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || val_ != nullptr);
  return value;
}
inline bool Term_AssocPair::has_val() const {
  return _internal_has_val();
}
inline void Term_AssocPair::clear_val() {
  if (val_ != nullptr) val_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::Term& Term_AssocPair::_internal_val() const {
  const ::Term* p = val_;
  return p != nullptr ? *p : *reinterpret_cast<const ::Term*>(
      &::_Term_default_instance_);
}
inline const ::Term& Term_AssocPair::val() const {
  // @@protoc_insertion_point(field_get:Term.AssocPair.val)
  return _internal_val();
}
inline ::Term* Term_AssocPair::release_val() {
  // @@protoc_insertion_point(field_release:Term.AssocPair.val)
  _has_bits_[0] &= ~0x00000002u;
  ::Term* temp = val_;
  val_ = nullptr;
  return temp;
}
inline ::Term* Term_AssocPair::_internal_mutable_val() {
  _has_bits_[0] |= 0x00000002u;
  if (val_ == nullptr) {
    auto* p = CreateMaybeMessage<::Term>(GetArenaNoVirtual());
    val_ = p;
  }
  return val_;
}
inline ::Term* Term_AssocPair::mutable_val() {
  // @@protoc_insertion_point(field_mutable:Term.AssocPair.val)
  return _internal_mutable_val();
}
inline void Term_AssocPair::set_allocated_val(::Term* val) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete val_;
  }
  if (val) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      val = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, val, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  val_ = val;
  // @@protoc_insertion_point(field_set_allocated:Term.AssocPair.val)
}

// -------------------------------------------------------------------

// Term

// optional .Term.TermType type = 1;
inline bool Term::_internal_has_type() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool Term::has_type() const {
  return _internal_has_type();
}
inline void Term::clear_type() {
  type_ = 1;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::Term_TermType Term::_internal_type() const {
  return static_cast< ::Term_TermType >(type_);
}
inline ::Term_TermType Term::type() const {
  // @@protoc_insertion_point(field_get:Term.type)
  return _internal_type();
}
inline void Term::_internal_set_type(::Term_TermType value) {
  assert(::Term_TermType_IsValid(value));
  _has_bits_[0] |= 0x00000002u;
  type_ = value;
}
inline void Term::set_type(::Term_TermType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:Term.type)
}

// optional .Datum datum = 2;
inline bool Term::_internal_has_datum() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || datum_ != nullptr);
  return value;
}
inline bool Term::has_datum() const {
  return _internal_has_datum();
}
inline void Term::clear_datum() {
  if (datum_ != nullptr) datum_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::Datum& Term::_internal_datum() const {
  const ::Datum* p = datum_;
  return p != nullptr ? *p : *reinterpret_cast<const ::Datum*>(
      &::_Datum_default_instance_);
}
inline const ::Datum& Term::datum() const {
  // @@protoc_insertion_point(field_get:Term.datum)
  return _internal_datum();
}
inline ::Datum* Term::release_datum() {
  // @@protoc_insertion_point(field_release:Term.datum)
  _has_bits_[0] &= ~0x00000001u;
  ::Datum* temp = datum_;
  datum_ = nullptr;
  return temp;
}
inline ::Datum* Term::_internal_mutable_datum() {
  _has_bits_[0] |= 0x00000001u;
  if (datum_ == nullptr) {
    auto* p = CreateMaybeMessage<::Datum>(GetArenaNoVirtual());
    datum_ = p;
  }
  return datum_;
}
inline ::Datum* Term::mutable_datum() {
  // @@protoc_insertion_point(field_mutable:Term.datum)
  return _internal_mutable_datum();
}
inline void Term::set_allocated_datum(::Datum* datum) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete datum_;
  }
  if (datum) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      datum = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, datum, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  datum_ = datum;
  // @@protoc_insertion_point(field_set_allocated:Term.datum)
}

// repeated .Term args = 3;
inline int Term::_internal_args_size() const {
  return args_.size();
}
inline int Term::args_size() const {
  return _internal_args_size();
}
inline void Term::clear_args() {
  args_.Clear();
}
inline ::Term* Term::mutable_args(int index) {
  // @@protoc_insertion_point(field_mutable:Term.args)
  return args_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Term >*
Term::mutable_args() {
  // @@protoc_insertion_point(field_mutable_list:Term.args)
  return &args_;
}
inline const ::Term& Term::_internal_args(int index) const {
  return args_.Get(index);
}
inline const ::Term& Term::args(int index) const {
  // @@protoc_insertion_point(field_get:Term.args)
  return _internal_args(index);
}
inline ::Term* Term::_internal_add_args() {
  return args_.Add();
}
inline ::Term* Term::add_args() {
  // @@protoc_insertion_point(field_add:Term.args)
  return _internal_add_args();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Term >&
Term::args() const {
  // @@protoc_insertion_point(field_list:Term.args)
  return args_;
}

// repeated .Term.AssocPair optargs = 4;
inline int Term::_internal_optargs_size() const {
  return optargs_.size();
}
inline int Term::optargs_size() const {
  return _internal_optargs_size();
}
inline void Term::clear_optargs() {
  optargs_.Clear();
}
inline ::Term_AssocPair* Term::mutable_optargs(int index) {
  // @@protoc_insertion_point(field_mutable:Term.optargs)
  return optargs_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Term_AssocPair >*
Term::mutable_optargs() {
  // @@protoc_insertion_point(field_mutable_list:Term.optargs)
  return &optargs_;
}
inline const ::Term_AssocPair& Term::_internal_optargs(int index) const {
  return optargs_.Get(index);
}
inline const ::Term_AssocPair& Term::optargs(int index) const {
  // @@protoc_insertion_point(field_get:Term.optargs)
  return _internal_optargs(index);
}
inline ::Term_AssocPair* Term::_internal_add_optargs() {
  return optargs_.Add();
}
inline ::Term_AssocPair* Term::add_optargs() {
  // @@protoc_insertion_point(field_add:Term.optargs)
  return _internal_add_optargs();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Term_AssocPair >&
Term::optargs() const {
  // @@protoc_insertion_point(field_list:Term.optargs)
  return optargs_;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)


PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::VersionDummy_Version> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::VersionDummy_Version>() {
  return ::VersionDummy_Version_descriptor();
}
template <> struct is_proto_enum< ::VersionDummy_Protocol> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::VersionDummy_Protocol>() {
  return ::VersionDummy_Protocol_descriptor();
}
template <> struct is_proto_enum< ::Query_QueryType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Query_QueryType>() {
  return ::Query_QueryType_descriptor();
}
template <> struct is_proto_enum< ::Frame_FrameType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Frame_FrameType>() {
  return ::Frame_FrameType_descriptor();
}
template <> struct is_proto_enum< ::Response_ResponseType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Response_ResponseType>() {
  return ::Response_ResponseType_descriptor();
}
template <> struct is_proto_enum< ::Response_ErrorType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Response_ErrorType>() {
  return ::Response_ErrorType_descriptor();
}
template <> struct is_proto_enum< ::Response_ResponseNote> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Response_ResponseNote>() {
  return ::Response_ResponseNote_descriptor();
}
template <> struct is_proto_enum< ::Datum_DatumType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Datum_DatumType>() {
  return ::Datum_DatumType_descriptor();
}
template <> struct is_proto_enum< ::Term_TermType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Term_TermType>() {
  return ::Term_TermType_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_rdb_5fprotocol_2fql2_2eproto
